<!doctype html> <meta charset=utf-8>
<script> // XRegExp 1.5.0
// (c) 2007-2010 Steven Levithan
// MIT License
// <http://xregexp.com>
// Provides an augmented, extensible, cross-browser implementation of regular expressions,
// including support for additional syntax, flags, and methods

var XRegExp;

if (XRegExp) {
    // Avoid running twice, since that would break references to native globals
    throw Error("can't load XRegExp twice in the same frame");
}

// Run within an anonymous function to protect variables and avoid new globals
(function () {

    //---------------------------------
    //  Constructor
    //---------------------------------

    // Accepts a pattern and flags; returns a new, extended `RegExp` object. Differs from a native
    // regular expression in that additional syntax and flags are supported and cross-browser
    // syntax inconsistencies are ameliorated
    XRegExp = function (pattern, flags) {
        var output = [],
            currScope = XRegExp.OUTSIDE_CLASS,
            pos = 0,
            context, tokenResult, match, chr, regex;

        if (XRegExp.isRegExp(pattern)) {
            if (flags !== undefined)
                throw TypeError("can't supply flags when constructing one RegExp from another");
            return clone(pattern);
        }
        // Tokens become part of the regex construction process, so protect against infinite
        // recursion when an XRegExp is constructed within a token handler or trigger
        if (isInsideConstructor)
            throw Error("can't call the XRegExp constructor within token definition functions");

        flags = flags || "";
        context = { // `this` object for custom tokens
            hasNamedCapture: false,
            captureNames: [],
            hasFlag: function (flag) {return flags.indexOf(flag) > -1;},
            setFlag: function (flag) {flags += flag;}
        };

        while (pos < pattern.length) {
            // Check for custom tokens at the current position
            tokenResult = runTokens(pattern, pos, currScope, context);

            if (tokenResult) {
                output.push(tokenResult.output);
                pos += (tokenResult.match[0].length || 1);
            } else {
                // Check for native multicharacter metasequences (excluding character classes) at
                // the current position
                if (match = real.exec.call(nativeTokens[currScope], pattern.slice(pos))) {
                    output.push(match[0]);
                    pos += match[0].length;
                } else {
                    chr = pattern.charAt(pos);
                    if (chr === "[")
                        currScope = XRegExp.INSIDE_CLASS;
                    else if (chr === "]")
                        currScope = XRegExp.OUTSIDE_CLASS;
                    // Advance position one character
                    output.push(chr);
                    pos++;
                }
            }
        }

        regex = RegExp(output.join(""), real.replace.call(flags, flagClip, ""));
        regex._xregexp = {
            source: pattern,
            captureNames: context.hasNamedCapture ? context.captureNames : null
        };
        return regex;
    };


    //---------------------------------
    //  Public properties
    //---------------------------------

    XRegExp.version = "1.5.0";

    // Token scope bitflags
    XRegExp.INSIDE_CLASS = 1;
    XRegExp.OUTSIDE_CLASS = 2;


    //---------------------------------
    //  Private variables
    //---------------------------------

    var replacementToken = /\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,
        flagClip = /[^gimy]+|([\s\S])(?=[\s\S]*\1)/g, // Nonnative and duplicate flags
        quantifier = /^(?:[?*+]|{\d+(?:,\d*)?})\??/,
        isInsideConstructor = false,
        tokens = [],
        // Copy native globals for reference ("native" is an ES3 reserved keyword)
        real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }(),
        compliantLastIndexReset = function () {
            var x = /x/g;
            real.replace.call("x", x, "");
            return !x.lastIndex;
        }(),
        hasNativeY = RegExp.prototype.sticky !== undefined,
        nativeTokens = {};

    // `nativeTokens` match native multicharacter metasequences only (including deprecated octals,
    // excluding character classes)
    nativeTokens[XRegExp.INSIDE_CLASS] = /^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;
    nativeTokens[XRegExp.OUTSIDE_CLASS] = /^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;


    //---------------------------------
    //  Public methods
    //---------------------------------

    // Lets you extend or change XRegExp syntax and create custom flags. This is used internally by
    // the XRegExp library and can be used to create XRegExp plugins. This function is intended for
    // users with advanced knowledge of JavaScript's regular expression syntax and behavior. It can
    // be disabled by `XRegExp.freezeTokens`
    XRegExp.addToken = function (regex, handler, scope, trigger) {
        tokens.push({
            pattern: clone(regex, "g" + (hasNativeY ? "y" : "")),
            handler: handler,
            scope: scope || XRegExp.OUTSIDE_CLASS,
            trigger: trigger || null
        });
    };

    // Accepts a pattern and flags; returns an extended `RegExp` object. If the pattern and flag
    // combination has previously been cached, the cached copy is returned; otherwise the newly
    // created regex is cached
    XRegExp.cache = function (pattern, flags) {
        var key = pattern + "/" + (flags || "");
        return XRegExp.cache[key] || (XRegExp.cache[key] = XRegExp(pattern, flags));
    };

    // Accepts a `RegExp` instance; returns a copy with the `/g` flag set. The copy has a fresh
    // `lastIndex` (set to zero). If you want to copy a regex without forcing the `global`
    // property, use `XRegExp(regex)`. Do not use `RegExp(regex)` because it will not preserve
    // special properties required for named capture
    XRegExp.copyAsGlobal = function (regex) {
        return clone(regex, "g");
    };

    // Accepts a string; returns the string with regex metacharacters escaped. The returned string
    // can safely be used at any point within a regex to match the provided literal string. Escaped
    // characters are [ ] { } ( ) * + ? - . , \ ^ $ | # and whitespace
    XRegExp.escape = function (str) {
        return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };

    // Accepts a string to search, regex to search with, position to start the search within the
    // string (default: 0), and an optional Boolean indicating whether matches must start at-or-
    // after the position or at the specified position only. This function ignores the `lastIndex`
    // property of the provided regex
    XRegExp.execAt = function (str, regex, pos, anchored) {
        regex = clone(regex, "g" + ((anchored && hasNativeY) ? "y" : ""));
        regex.lastIndex = pos = pos || 0;
        var match = regex.exec(str);
        if (anchored)
            return (match && match.index === pos) ? match : null;
        else
            return match;
    };

    // Breaks the unrestorable link to XRegExp's private list of tokens, thereby preventing
    // syntax and flag changes. Should be run after XRegExp and any plugins are loaded
    XRegExp.freezeTokens = function () {
        XRegExp.addToken = function () {
            throw Error("can't run addToken after freezeTokens");
        };
    };

    // Accepts any value; returns a Boolean indicating whether the argument is a `RegExp` object.
    // Note that this is also `true` for regex literals and regexes created by the `XRegExp`
    // constructor. This works correctly for variables created in another frame, when `instanceof`
    // and `constructor` checks would fail to work as intended
    XRegExp.isRegExp = function (o) {
        return Object.prototype.toString.call(o) === "[object RegExp]";
    };

    // Executes `callback` once per match within `str`. Provides a simpler and cleaner way to
    // iterate over regex matches compared to the traditional approaches of subverting
    // `String.prototype.replace` or repeatedly calling `exec` within a `while` loop
    XRegExp.iterate = function (str, origRegex, callback, context) {
        var regex = clone(origRegex, "g"),
            i = -1, match;
        while (match = regex.exec(str)) {
            callback.call(context, match, ++i, str, regex);
            if (regex.lastIndex === match.index)
                regex.lastIndex++;
        }
        if (origRegex.global)
            origRegex.lastIndex = 0;
    };

    // Accepts a string and an array of regexes; returns the result of using each successive regex
    // to search within the matches of the previous regex. The array of regexes can also contain
    // objects with `regex` and `backref` properties, in which case the named or numbered back-
    // references specified are passed forward to the next regex or returned. E.g.:
    // var xregexpImgFileNames = XRegExp.matchChain(html, [
    //     {regex: /<img\b([^>]+)>/i, backref: 1}, // <img> tag attributes
    //     {regex: XRegExp('(?ix) \\s src=" (?<src> [^"]+ )'), backref: "src"}, // src attribute values
    //     {regex: XRegExp("^http://xregexp\\.com(/[^#?]+)", "i"), backref: 1}, // xregexp.com paths
    //     /[^\/]+$/ // filenames (strip directory paths)
    // ]);
    XRegExp.matchChain = function (str, chain) {
        return function recurseChain (values, level) {
            var item = chain[level].regex ? chain[level] : {regex: chain[level]},
                regex = clone(item.regex, "g"),
                matches = [], i;
            for (i = 0; i < values.length; i++) {
                XRegExp.iterate(values[i], regex, function (match) {
                    matches.push(item.backref ? (match[item.backref] || "") : match[0]);
                });
            }
            return ((level === chain.length - 1) || !matches.length) ?
                matches : recurseChain(matches, level + 1);
        }([str], 0);
    };


    //---------------------------------
    //  New RegExp prototype methods
    //---------------------------------

    // Accepts a context object and arguments array; returns the result of calling `exec` with the
    // first value in the arguments array. the context is ignored but is accepted for congruity
    // with `Function.prototype.apply`
    RegExp.prototype.apply = function (context, args) {
        return this.exec(args[0]);
    };

    // Accepts a context object and string; returns the result of calling `exec` with the provided
    // string. the context is ignored but is accepted for congruity with `Function.prototype.call`
    RegExp.prototype.call = function (context, str) {
        return this.exec(str);
    };


    //---------------------------------
    //  Overriden native methods
    //---------------------------------

    // Adds named capture support (with backreferences returned as `result.name`), and fixes two
    // cross-browser issues per ES3:
    // - Captured values for nonparticipating capturing groups should be returned as `undefined`,
    //   rather than the empty string.
    // - `lastIndex` should not be incremented after zero-length matches.
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if (match) {
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                real.replace.call(str.toString().slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            // Attach named capture properties
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };

    // Don't override `test` if it won't change anything
    if (!compliantLastIndexIncrement) {
        // Fix browser bug in native method
        RegExp.prototype.test = function (str) {
            // Use the native `exec` to skip some processing overhead, even though the overriden
            // `exec` would take care of the `lastIndex` fix
            var match = real.exec.call(this, str);
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    // Adds named capture support and fixes browser bugs in native method
    String.prototype.match = function (regex) {
        if (!XRegExp.isRegExp(regex))
            regex = RegExp(regex); // Native `RegExp`
        if (regex.global) {
            var result = real.match.apply(this, arguments);
            regex.lastIndex = 0; // Fix IE bug
            return result;
        }
        return regex.exec(this); // Run the altered `exec`
    };

    // Adds support for `${n}` tokens for named and numbered backreferences in replacement text,
    // and provides named backreferences to replacement functions as `arguments[0].name`. Also
    // fixes cross-browser differences in replacement text syntax when performing a replacement
    // using a nonregex search value, and the value of replacement regexes' `lastIndex` property
    // during replacement iterations. Note that this doesn't support SpiderMonkey's proprietary
    // third (`flags`) parameter
    String.prototype.replace = function (search, replacement) {
        var isRegex = XRegExp.isRegExp(search),
            captureNames, result, str;

        // There are many combinations of search/replacement types/values and browser bugs that
        // preclude passing to native `replace`, so just keep this check relatively simple
        if (isRegex && typeof replacement.valueOf() === "string" && replacement.indexOf("${") === -1 && compliantLastIndexReset)
            return real.replace.apply(this, arguments);

        if (!isRegex)
            search = search + ""; // Type conversion
        else if (search._xregexp)
            captureNames = search._xregexp.captureNames; // Array or `null`

        if (typeof replacement === "function") {
            result = real.replace.call(this, search, function () {
                if (captureNames) {
                    // Change the `arguments[0]` string primitive to a String object which can store properties
                    arguments[0] = new String(arguments[0]);
                    // Store named backreferences on `arguments[0]`
                    for (var i = 0; i < captureNames.length; i++) {
                        if (captureNames[i])
                            arguments[0][captureNames[i]] = arguments[i + 1];
                    }
                }
                // Update `lastIndex` before calling `replacement`
                if (isRegex && search.global)
                    search.lastIndex = arguments[arguments.length - 2] + arguments[0].length;
                return replacement.apply(null, arguments);
            });
        } else {
            str = this + ""; // Type conversion, so `args[args.length - 1]` will be a string (given nonstring `this`)
            result = real.replace.call(str, search, function () {
                var args = arguments; // Keep this function's `arguments` available through closure
                return real.replace.call(replacement, replacementToken, function ($0, $1, $2) {
                    // Numbered backreference (without delimiters) or special variable
                    if ($1) {
                        switch ($1) {
                            case "$": return "$";
                            case "&": return args[0];
                            case "`": return args[args.length - 1].slice(0, args[args.length - 2]);
                            case "'": return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                            // Numbered backreference
                            default:
                                // What does "$10" mean?
                                // - Backreference 10, if 10 or more capturing groups exist
                                // - Backreference 1 followed by "0", if 1-9 capturing groups exist
                                // - Otherwise, it's the string "$10"
                                // Also note:
                                // - Backreferences cannot be more than two digits (enforced by `replacementToken`)
                                // - "$01" is equivalent to "$1" if a capturing group exists, otherwise it's the string "$01"
                                // - There is no "$0" token ("$&" is the entire match)
                                var literalNumbers = "";
                                $1 = +$1; // Type conversion; drop leading zero
                                if (!$1) // `$1` was "0" or "00"
                                    return $0;
                                while ($1 > args.length - 3) {
                                    literalNumbers = String.prototype.slice.call($1, -1) + literalNumbers;
                                    $1 = Math.floor($1 / 10); // Drop the last digit
                                }
                                return ($1 ? args[$1] || "" : "$") + literalNumbers;
                        }
                    // Named backreference or delimited numbered backreference
                    } else {
                        // What does "${n}" mean?
                        // - Backreference to numbered capture n. Two differences from "$n":
                        //   - n can be more than two digits
                        //   - Backreference 0 is allowed, and is the entire match
                        // - Backreference to named capture n, if it exists and is not a number overridden by numbered capture
                        // - Otherwise, it's the string "${n}"
                        var n = +$2; // Type conversion; drop leading zeros
                        if (n <= args.length - 3)
                            return args[n];
                        n = captureNames ? indexOf(captureNames, $2) : -1;
                        return n > -1 ? args[n + 1] : $0;
                    }
                });
            });
        }

        if (isRegex && search.global)
            search.lastIndex = 0; // Fix IE bug

        return result;
    };

    // A consistent cross-browser, ES3 compliant `split`
    String.prototype.split = function (s /* separator */, limit) {
        // If separator `s` is not a regex, use the native `split`
        if (!XRegExp.isRegExp(s))
            return real.split.apply(this, arguments);

        var str = this + "", // Type conversion
            output = [],
            lastLastIndex = 0,
            match, lastLength;

        // Behavior for `limit`: if it's...
        // - `undefined`: No limit
        // - `NaN` or zero: Return an empty array
        // - A positive number: Use `Math.floor(limit)`
        // - A negative number: No limit
        // - Other: Type-convert, then use the above rules
        if (limit === undefined || +limit < 0) {
            limit = Infinity;
        } else {
            limit = Math.floor(+limit);
            if (!limit)
                return [];
        }

        // This is required if not `s.global`, and it avoids needing to set `s.lastIndex` to zero
        // and restore it to its original value when we're done using the regex
        s = XRegExp.copyAsGlobal(s);

        while (match = s.exec(str)) { // Run the altered `exec` (required for `lastIndex` fix, etc.)
            if (s.lastIndex > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));

                if (match.length > 1 && match.index < str.length)
                    Array.prototype.push.apply(output, match.slice(1));

                lastLength = match[0].length;
                lastLastIndex = s.lastIndex;

                if (output.length >= limit)
                    break;
            }

            if (s.lastIndex === match.index)
                s.lastIndex++;
        }

        if (lastLastIndex === str.length) {
            if (!real.test.call(s, "") || lastLength)
                output.push("");
        } else {
            output.push(str.slice(lastLastIndex));
        }

        return output.length > limit ? output.slice(0, limit) : output;
    };


    //---------------------------------
    //  Private helper functions
    //---------------------------------

    // Supporting function for `XRegExp`, `XRegExp.copyAsGlobal`, etc. Returns a copy of a `RegExp`
    // instance with a fresh `lastIndex` (set to zero), preserving properties required for named
    // capture. Also allows adding new flags in the process of copying the regex
    function clone (regex, additionalFlags) {
        if (!XRegExp.isRegExp(regex))
            throw TypeError("type RegExp expected");
        var x = regex._xregexp;
        regex = XRegExp(regex.source, getNativeFlags(regex) + (additionalFlags || ""));
        if (x) {
            regex._xregexp = {
                source: x.source,
                captureNames: x.captureNames ? x.captureNames.slice(0) : null
            };
        }
        return regex;
    };

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    };

    function runTokens (pattern, index, scope, context) {
        var i = tokens.length,
            result, match, t;
        // Protect against constructing XRegExps within token handler and trigger functions
        isInsideConstructor = true;
        // Must reset `isInsideConstructor`, even if a `trigger` or `handler` throws
        try {
            while (i--) { // Run in reverse order
                t = tokens[i];
                if ((scope & t.scope) && (!t.trigger || t.trigger.call(context))) {
                    t.pattern.lastIndex = index;
                    match = t.pattern.exec(pattern); // Running the altered `exec` here allows use of named backreferences, etc.
                    if (match && match.index === index) {
                        result = {
                            output: t.handler.call(context, match, scope),
                            match: match
                        };
                        break;
                    }
                }
            }
        } catch (err) {
            throw err;
        } finally {
            isInsideConstructor = false;
        }
        return result;
    };

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    };


    //---------------------------------
    //  Built-in tokens
    //---------------------------------

    // Augment XRegExp's regular expression syntax and flags. Note that when adding tokens, the
    // third (`scope`) argument defaults to `XRegExp.OUTSIDE_CLASS`

    // Comment pattern: (?# )
    XRegExp.addToken(
        /\(\?#[^)]*\)/,
        function (match) {
            // Keep tokens separated unless the following token is a quantifier
            return real.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? "" : "(?:)";
        }
    );

    // Capturing group (match the opening parenthesis only).
    // Required for support of named capturing groups
    XRegExp.addToken(
        /\((?!\?)/,
        function () {
            this.captureNames.push(null);
            return "(";
        }
    );

    // Named capturing group (match the opening delimiter only): (?<name>
    XRegExp.addToken(
        /\(\?<([$\w]+)>/,
        function (match) {
            this.captureNames.push(match[1]);
            this.hasNamedCapture = true;
            return "(";
        }
    );

    // Named backreference: \k<name>
    XRegExp.addToken(
        /\\k<([\w$]+)>/,
        function (match) {
            var index = indexOf(this.captureNames, match[1]);
            // Keep backreferences separate from subsequent literal numbers. Preserve back-
            // references to named groups that are undefined at this point as literal strings
            return index > -1 ?
                "\\" + (index + 1) + (isNaN(match.input.charAt(match.index + match[0].length)) ? "" : "(?:)") :
                match[0];
        }
    );

    // Empty character class: [] or [^]
    XRegExp.addToken(
        /\[\^?]/,
        function (match) {
            // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
            // (?!) should work like \b\B, but is unreliable in Firefox
            return match[0] === "[]" ? "\\b\\B" : "[\\s\\S]";
        }
    );

    // Mode modifier at the start of the pattern only, with any combination of flags imsx: (?imsx)
    // Does not support x(?i), (?-i), (?i-m), (?i: ), (?i)(?m), etc.
    XRegExp.addToken(
        /^\(\?([imsx]+)\)/,
        function (match) {
            this.setFlag(match[1]);
            return "";
        }
    );

    // Whitespace and comments, in free-spacing (aka extended) mode only
    XRegExp.addToken(
        /(?:\s+|#.*)+/,
        function (match) {
            // Keep tokens separated unless the following token is a quantifier
            return real.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? "" : "(?:)";
        },
        XRegExp.OUTSIDE_CLASS,
        function () {return this.hasFlag("x");}
    );

    // Dot, in dotall (aka singleline) mode only
    XRegExp.addToken(
        /\./,
        function () {return "[\\s\\S]";},
        XRegExp.OUTSIDE_CLASS,
        function () {return this.hasFlag("s");}
    );


    //---------------------------------
    //  Backward compatibility
    //---------------------------------

    // Uncomment the following block for compatibility with XRegExp 1.0-1.2:
    /*
    XRegExp.matchWithinChain = XRegExp.matchChain;
    RegExp.prototype.addFlags = function (s) {return clone(this, s);};
    RegExp.prototype.execAll = function (s) {var r = []; XRegExp.iterate(s, this, function (m) {r.push(m);}); return r;};
    RegExp.prototype.forEachExec = function (s, f, c) {return XRegExp.iterate(s, this, f, c);};
    RegExp.prototype.validate = function (s) {var r = RegExp("^(?:" + this.source + ")$(?!\\s)", getNativeFlags(this)); if (this.global) this.lastIndex = 0; return s.search(r) === 0;};
    */

})();

// CommonJS
typeof(exports) != 'undefined' ? exports.XRegExp = XRegExp : null;
 </script>
<script> //
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
if (typeof(SyntaxHighlighter) == 'undefined') var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,

		'unindent' : true,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '@ABOUT@'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;#]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		/** <script> tags. */
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split(/\r?\n/);
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	// include \r to enable copy-paste on windows (ie8) without getting everything on one line
	return lines.join('\r\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		if (this.getParam('unindent'))
			code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports.SyntaxHighlighter = SyntaxHighlighter : null;
 </script>
<style> .syntaxhighlighter {
  background-color: #f5f5ff !important;
  border: solid 1px #e5e5ee !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .keyword {
  font-weight: bold !important;
}
.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}
 </style>
<script> /**
 * This code contains an implementation of HTML5 outlining algorithm, as described by WHATWG at [1]
 *
 * The copyright notice at [2] says:
 *		(c) Copyright 2004-2009 Apple Computer, Inc., Mozilla Foundation, and Opera Software ASA.
 *		You are granted a license to use, reproduce and create derivative works of this document.
 *
 * [1] http://www.whatwg.org/specs/web-apps/current-work/multipage/sections.html#outlines
 * [2] http://www.whatwg.org/specs/web-apps/current-work/multipage/index.html
 */
(function(){var i=function(a){this.sections=[];this.startingNode=a};i.prototype={heading:false,append:function(a){a.container=this;this.sections.push(a)},asHTML:function(a){var b=u(this.heading);if(a)b='<a href="#'+v(this.startingNode)+'">'+b+"</a>";return b+q(this.sections,a)}};var q=function(a,b){for(var f="",c=0;c<a.length;c++)f+="<li>"+a[c].asHTML(b)+"</li>";return f==""?f:"<ol>"+f+"</ol>"},r=function(a){a=a.heading;return h(a)?j(a):1},u=function(a){if(h(a)){if(k(a)=="HGROUP")a=a.getElementsByTagName("h"+
-j(a))[0];return a.textContent||a.innerText||"<i>No text content inside "+a.nodeName+"</i>"}return""+a},v=function(a){var b=a.getAttribute("id");if(b)return b;do b="h5o-"+ ++s;while(t.getElementById(b));a.setAttribute("id",b);return b},e,d,g,s,t,w=function(a,b,f){var c=a;a:for(;c;){b(c);if(c.firstChild){c=c.firstChild;continue a}for(;c;){f(c);if(c.nextSibling){c=c.nextSibling;continue a}c=c==a?null:c.parentNode}}},x=function(a){if(!h(o(g)))if(l(a)||m(a)){e!=null&&g.push(e);e=a;d=new i(a);e.outline=
{sections:[d],startingNode:a,asHTML:function(c){return q(this.sections,c)}}}else if(e!=null)if(h(a)){if(d.heading)if(j(a)>=r(n(e.outline))){var b=new i(a);e.outline.sections.push(b);d=b;d.heading=a}else{b=false;var f=d;do{if(j(a)<r(f)){b=new i(a);f.append(b);d=b;d.heading=a;b=true}f=f.container}while(!b)}else d.heading=a;g.push(a)}},y=function(a){var b=o(g);if(h(b))b==a&&g.pop();else{if((l(a)||m(a))&&!d.heading)d.heading="<i>Untitled "+k(a)+"</i>";if(l(a)&&g.length>0){e=g.pop();d=n(e.outline);for(b=
0;b<a.outline.sections.length;b++)d.append(a.outline.sections[b])}else if(m(a)&&g.length>0){e=g.pop();for(d=n(e.outline);d.sections.length>0;)d=n(d)}else if(l(a)||m(a))d=e.outline.sections[0]}},k=function(a){return a.tagName.toUpperCase()},p=function(a){return function(b){return z(b)&&(new RegExp(a,"i")).test(k(b))}},m=p("^BLOCKQUOTE|BODY|DETAILS|FIELDSET|FIGURE|TD$"),l=p("^ARTICLE|ASIDE|NAV|SECTION$"),h=p("^H[1-6]|HGROUP$"),z=function(a){return a&&a.tagName},j=function(a){var b=k(a);if(b=="HGROUP")for(b=
1;b<=6;b++){if(a.getElementsByTagName("H"+b).length>0)return-b}else return-parseInt(b.substr(1))},n=function(a){return o(a.sections)},o=function(a){return a[a.length-1]};HTML5Outline=function(a){s=0;t=a.ownerDocument||window.document;d=e=null;g=[];w(a,x,y);return e!=null?e.outline:null}})();
 </script>
<style> pre
{
  background-color: #f5f5ff;
  border: solid #e5e5ee 1px;
  text-align: left;
}

.code
{
  margin-top: 1em;
}

body
{
  font-family: sans-serif;
  font-size: 0.95em;
  margin: 0;
  padding: 0;
}

h1, h2, h3, h4, h5, h6
{
  font-family: sans-serif;
  color: #535388;
}

a,
a:hover
{
  text-decoration: none;
  color: #535388;
}

article
{
  position: absolute;
  z-index: 1;
  margin: 0;
  margin-left: 11em;
  padding: 0;
  padding-left: 1em;
  width: 38em;
  text-align: justify;
  background-color: white;
}

article > h1
{ font-size: 2.2em }

article > h2,
article > section > h1
{ font-size: 1.6em }

article > h3,
article > section > h2,
article > section > section > h1
{ font-size: 1.3em }

article > h4,
article h5,
article h6,
article > section > h3,
article > section > section > h2,
article > section > section > section > h1
{ font-size: 1em }

article > h1
{
  color: white;
  background-color: #9393aa;
  margin: 0;
  padding: 0.5em 0 0.8em 0;
  text-align: center;
}

div#outline
{
  position: fixed;
  top: 2em;
  left: 0.5em;
  width: 10em;
}

div#outline > ol
{ font-size: 0.8em }

div#outline ol ol ol ol ol
{
  display: none;
}

div#code-anchors
{
  position: absolute;
  top: 2em;
  left: 51em;
  padding-right: 1em;
}

div#code-anchors > ul
{
  font-family: monospace;
  font-size: 0.8em;
}

div#code-anchors > ul ul
{
  padding-bottom: 1em;
}

div#outline ol,
div#code-anchors ul
{
  margin-left: 0;
  padding-left: 1em;
  padding-right: 0;
  list-style-type: none;
  text-indent: -2em;
}

div#outline,
div#code-anchors
{
  padding-left: 1em;
  color: #535388;
}

div#outline a,
div#code-anchors a,
div#outline a:visited,
div#code-anchors a:visited
{
  text-decoration: none;
  color: #9393aa;
}

div#outline > ol > li > a,
div#outline > ol > li > a:visited
{
  color: #535388;
}

div.test
{
  border-left: #9393aa 1px dotted;
  margin-left: -10px;
  padding-left: 9px;
}

div.test-toggle
{
  position: absolute;
  margin-left: -1em;
  width: 1em;
  font-size: 0.8em;
  font-weight: bold;
  color: #9393aa;
  cursor: pointer;
}

div#master-toggle
{
  margin-left: -1em;
  font-size: 0.8em;
  font-weight: bold;
  color: #9393aa;
  cursor: pointer;
}
 </style>
<article><a id='project.clj/A-programming-story'></a>
<h1>A programming story</h1><p>This is the story of a small program that parses source code. It converts comments into HTML (via <a href="http://daringfireball.net/projects/markdown/">Markdown</a>) and nicely highlights code (using <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>).</p>
<a id='project.clj/story'></a>
<pre class='brush: clojure'>(defproject
  story "0.0.3-SNAPSHOT"

  :description "A literate programming tool."
</pre>
<p>The program is written in the <a href="http://clojure.org">Clojure</a> language and uses the <a href="https://github.com/sirthias/pegdown">pegdown</a> implementation of Markdown with a number of its extensions <a href="#src/story/core.clj/Pegdown-instances">enabled</a>.</p><p>It uses clojure 1.2.1 for now because that is what [Leiningen] 1.x uses and at some stage there will be a lein-story plugin.</p>
<pre class='brush: clojure'>  :dependencies
  [[org.clojure/clojure "1.2.1"]
   [org.pegdown/pegdown "1.1.0"]
   [fs "0.11.0"]
</pre>
<p>A <a href="https://github.com/jedahu/tools.cli">modified</a> <code>org.clojure/tools.cli</code> is used (for repeated options). To be merged with upstream by <code>0.1.0</code>.</p>
<pre class='brush: clojure'>   [me.panzoo/tools.cli "0.2.2"]]
  
  :main story.main)
</pre>
<p>Check out the sources at <a href="https://github.com/jedahu/story">https://github.com/jedahu/story</a></p>
<a id='project.clj/Synopsis'></a>
<h2>Synopsis</h2><p>To use this program you need to know four things: the single-line comment syntax of your source-code, Markdown, the story syntax for anchors, and the story syntax for includes.</p><p>Comment blocks that are flush with the left margin are parsed and rendered using Markdown, those prefixed with whitespace are ignored. Anchors are comment lines whose content is &lsquo;<code>@&lt;anchor-id&gt;</code>&rsquo;. To include another source file add a comment line whose content is &lsquo;<code>%include &lt;file-path&gt;</code>&rsquo;.</p><p>By default this program is set up to process a Lisp like language with single semi-colon comment tokens. A small source example with anchors, includes, and wiki links might look like this:</p>
<pre class='brush: clojure'>
;;<. Copyright (c) 2012, Me <me@example.com>
;;
;; Boring license notice.
;; Blah blah blah.
;;
;; This section will not show in the documentation.
;;.>

;; # My awesome program
;;
;; Introductory paragraph, uses *Markdown*. Fast forward to the
;; [[last paragraph]].
;;
;; Blah blah blah.

;;. This comment will not show in the documentation.
(defn hello []
  (println "Hello world!"))

;;&lt;?
(assert (= (hello) "Hello world!"))
;;?&gt;

;;%require config.xml

;;%include fibonacci.clj
;;%include fibonacci.js // javascript
;;
;;@last paragraph
;; This is the last paragraph. Go back to the [[hello]] function. Go to the
;; [[fibonacci.clj/fib]] function.
</pre>
<a id='project.clj/Includes'></a>
<h3>Includes</h3><p>As you can see, files written in different languages can be included. In this example <code>fibonacci.js</code> is followed by the comment syntax and language name to use with SyntaxHighlighter. For a number of languages (including javascript) this information can be obtained from the file extension and the appropriate brush file pulled in automatically; those languages are listed in the <a href="#src/story/core.clj/Language-map">Language map</a>.</p>
<a id='project.clj/Test-code-and-production'></a>
<h3>Test code and production</h3><p>Test code can be included inline using <code>&lt;?</code> and <code>?&gt;</code>, and commented out for production. The <code>%require</code> directive marks a file or directory for production use without including it in the documentation. See <a href="#src/story/core.clj/Testing">Testing</a> for more detail.</p>
<a id='project.clj/Internal-links'></a>
<h3>Internal links</h3><p>Wiki style links (<code>[[link]]</code>) point to explicit anchors (<code>;@&lt;id&gt;</code>) or to implicit anchors (the names of definitions). Implicit anchors are created for Markdown headings (#-style only) and definitions in code (only for languages with methods for <code>story.core/</code><a href="#src/story/core.clj/code-anchor-id">code-anchor-id</a>; be aware, not all methods have been well tested).</p><p>Wiki links to anchors in other files must be qualified by the file&rsquo;s path. The markup for the link to <code>code-anchor-id</code> looks like this: <code>[[src/story/core.clj/code-anchor-id]]</code>.</p><p>If any anchors for code definitions are created, an alphabetical TOC like list of links to those anchors will appear on the right side of the page.</p>
<a id='project.clj/Build-instructions'></a>
<h3>Build instructions</h3><p>To build <code>story.jar</code> make sure <a href="https://github.com/technomancy/leiningen">Leiningen</a> is installed and run the following commands in the story project directory:</p>
<pre><code>lein deps
lein uberjar
</code></pre><p>If all goes well a file named something like <code>story-x.x.x-standalone.jar</code> will have magically appeared in the project directory. Rename it to <code>story.jar</code> if you like.</p>
<a id='project.clj/Command-line-usage'></a>
<h3>Command line usage</h3>
<pre><code>java -jar story.jar input-files output
</code></pre><p>If <code>output</code> is absent, the program&rsquo;s output is streamed to standard-out. For more detail run the program with the <code>--help</code> option or have a look at the <a href="#src/story/core.clj/Commandline">Commandline</a> section.</p><p>This HTML document (assuming you are not reading the source file) was created by the command: <code>java -jar story.jar project.clj index.html</code>.</p>
<a id='project.clj/Programmatic-usage'></a>
<h3>Programmatic usage</h3><p>Call <code>story.core/</code><a href="#src/story/core.clj/process-files">process-files</a> with a list of file paths and an output stream or file-path. It may be necessary to set up bindings for one or more of the dynamic variables described in the <a href="#src/story/core.clj/Top-level-variables">Top level variables</a> section depending on whether the file suffixes are in the <a href="#src/story/core.clj/Language-map">Language map</a> or not.</p><p>The equivalent of the above commandline invocation is: <code>(process-files
[&quot;project.clj&quot;] &quot;index.html&quot;)</code>.</p>
<section><a id='src/story/core.clj/The-code'></a>
<h1>The code</h1><p>The code is Copyright (c) Jeremy Hughes 2011 and is available under the <a href="http://en.wikipedia.org/wiki/ISC_license">ISC</a> license, except for the <a href="#src/story/core.clj/cond-let">cond-let</a>, <a href="#src/story/core.clj/read-lines">read-lines</a>, and <a href="#src/story/core.clj/write-lines">write-lines</a> functions which are Copyright (c) Rich Hickey and are under the <a href="http://www.eclipse.org/org/documents/epl-v10.php">EPL</a>. These licenses are in the root of this source distribution in the files <code>LICENSE</code> and <code>epl-v10.html</code>.</p><p>The usual stuff comes first. This code needs to read and write to files, manipulate strings, and parse Markdown.</p>
<pre class='brush: clojure'>(ns story.core
  (:refer-clojure :exclude [comment])
  (:require
    [clojure.java.io :as io]
    [clojure.string :as string]
    fs)
  (:import
    [java.util.regex Pattern]
    [java.io BufferedReader BufferedWriter]
    [org.pegdown PegDownProcessor Extensions
</pre>
<p>Internal links (to element ids) are nice to have. These imports will be used to create a modified LinkRenderer.</p>
<pre class='brush: clojure'>     LinkRenderer LinkRenderer$Rendering]
    [org.pegdown.ast WikiLinkNode]))
</pre>
<p>A few of the top level variables use these utility functions.</p>
<pre class='brush: clojure'>
(declare normalize-anchor)
(declare html-escape)
</pre>
<a id='src/story/core.clj/Top-level-variables'></a>
<h2>Top level variables</h2><p>A few objects need to be accessed by a number of functions: regular expressions that match the beginning of lines, SyntaxHighlighter options, a PegDownProcessor, and a modified LinkRenderer.</p>
<a id='src/story/core.clj/Settings'></a>
<h3>Settings</h3><p>This dynamic variable is bound once in the commandline <code>-main</code> method and is never subsequently altered by the code in this namespace. The variable is bound to a map containing the following settings: which SyntaxHighlighter theme to use; which SyntaxHighlighter brushes to include to start with (other brushes may be added automatically by the program); what CSS file to include if any; and whether to log messages to std-err or not.</p>
<a id='src/story/core.clj/*settings*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *settings*
  {:theme "shThemeEclipse.css"
   :static-brushes []
   :stylesheet nil
   :verbose? false})

</pre>
<a id='src/story/core.clj/Per-input-file'></a>
<h3>Per input file</h3><p>These variables are rebound for every input file.</p>
<a id='src/story/core.clj/*single-comment*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *single-comment*
  ; "A string containing a single comment token."
  ";;")
</pre>
<a id='src/story/core.clj/*language*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *language*
  ; "A language string for use with SyntaxHighlighter."
  :clojure)
</pre>
<a id='src/story/core.clj/*path*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *path*
  ; "The path of the file currently being processed."
  nil)

</pre>
<a id='src/story/core.clj/Per-output-stream'></a>
<h3>Per output stream</h3><p>These variables are given bindings only in the <a href="#src/story/core.clj/render-files">render-files</a> function.</p><p>Brushes can be added by the program whenever a new file is processed.</p>
<a id='src/story/core.clj/*brushes*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *brushes* nil)
</pre>
<a id='src/story/core.clj/*code-anchors*'></a>
<pre class='brush: clojure'>(def ^{:dynamic true} *code-anchors* nil)

</pre>
<a id='src/story/core.clj/Language-map'></a>
<h3>Language map</h3><p>Including SyntaxHighlighter brush files automatically based on file suffix or the language argument to an include directive is preferrable to explicitly listing brushes on the commandline or in a program that calls this one. Comment syntax is listed here too for the same reason.</p><p>Don&rsquo;t use <code>languages</code> and <code>language-aliases</code> directly. Use <a href="#src/story/core.clj/lang-info">lang-info</a>, <a href="#src/story/core.clj/lang-brush">lang-brush</a>, and <a href="#src/story/core.clj/lang-comment">lang-comment</a> instead. Those three functions route their input through <a href="#src/story/core.clj/canonical-lang">canonical-lang</a> which resolves any aliases to their canonical equivalent.</p>
<a id='src/story/core.clj/languages'></a>
<pre class='brush: clojure'>(def languages
  ; "A map of language names to a pairs of comment syntax and SyntaxHighlighter
  ; brush file names."
  {:clojure [";;" "shBrushClojure.js"]
   :applescript ["--" "shBrushAppleScript.js"]
   :as3 ["//" "shBrushAS3.js"]
   :bash ["#" "shBrushBash.js"]
   :shell ["#" "shBrushBash.js"]
   :sh ["#" "shBrushBash.js"]
   :cpp ["//" "shBrushCpp.js"]
   :c++ ["//" "shBrushCpp.js"]
   :cxx ["//" "shBrushCpp.js"]
   :c ["//" "shBrushCpp.js"]
   :c# ["//" "shBrushCSharp.js"]
   :c-sharp ["//" "shBrushCSharp.js"]
   :csharp ["//" "shBrushCSharp.js"]
   :delphi ["//" "shBrushDelphi.js"]
   :pascal ["//" "shBrushDelphi.js"]
   :erlang ["%" "shBrushErlang.js"]
   :erl ["%" "shBrushErlang.js"]
   :groovy ["//" "shBrushGroovy.js"]
   :java ["//" "shBrushJava.js"]
   :javafx ["//" "shBrushJavaFX.js"]
   :jfx ["//" "shBrushJavaFX.js"]
   :javascript ["//" "shBrushJScript.js"]
   :js ["//" "shBrushJScript.js"]
   :perl ["#" "shBrushPerl.js"]
   :pl ["#" "shBrushPerl.js"]
   :php ["#" "shBrushPhp.js"]
   :python ["#" "shBrushPython.js"]
   :py ["#" "shBrushPython.js"]
   :ruby ["#" "shBrushRuby.js"]
   :rb ["#" "shBrushRuby.js"]
   :sass ["//" "shBrushSass.js"]
   :scss ["//" "shBrushSass.js"]
   :scala ["//" "shBrushScala.js"]
   :sql ["--" "shBrushSql.js"]
   :vim ["\"" "shBrushVimscript.js"]
   :vimscript ["\"" "shBrushVimscript.js"]
   :vb ["'" "shBrushVb.js"]
   :vbnet ["'" "shBrushVb.js"]
   :markdown ["" nil]
   })
</pre>
<a id='src/story/core.clj/language-aliases'></a>
<pre class='brush: clojure'>(def language-aliases
  ; "A map of aliases to canonical language names."
  {:clj :clojure
   :cljs :clojure
   :actionscript3 :as3
   :sh :bash
   :shell :bash
   :c :cpp
   :c++ :cpp
   :cxx :cpp
   :c# :csharp
   :c-sharp :csharp
   :erl :erlang
   :jfx :javafx
   :js :javascript
   :pl :perl
   :py :python
   :rb :ruby
   :sass :scss
   :vimscript :vim
   :vbnet :vb
   :md :markdown})

</pre>
<a id='src/story/core.clj/Pegdown-instances'></a>
<h3>Pegdown instances</h3><p>The same <a href="http://www.decodified.com/pegdown/api/org/pegdown/PegDownProcessor.html">pegdown processor</a> and <a href="http://www.decodified.com/pegdown/api/org/pegdown/LinkRenderer.html">link renderer</a> are used for each program execution.</p>
<a id='src/story/core.clj/processor'></a>
<pre class='brush: clojure'>(def processor
  ; "A PegDownProcessor set up with the following extensions:
  ; AUTOLINKS
  ; SMARTYPANTS
  ; FENCED_CODE_BLOCKS
  ; DEFINITIONS
  ; WIKILINKS"
  (PegDownProcessor.
    (reduce bit-or
            [(. Extensions AUTOLINKS)
             (. Extensions SMARTYPANTS)
             (. Extensions FENCED_CODE_BLOCKS)
             (. Extensions DEFINITIONS)
             (. Extensions WIKILINKS)])))
</pre>
<p>Pegdown&rsquo;s link rendering is overriden for the wiki link case. Un-qualified links are given a qualified <code>href</code>, and qualified links are given an unqualified value. <a href="#src/story/core.clj/normalize-anchor">normalize-anchor</a> is used to normalize the <code>href</code>. For example, in the file path/to/foo.c, these wiki links:</p>
<pre><code>[[one link]]
[[path/to/bar.c/another link]]
</code></pre><p>create this output:</p>
<pre><code>&lt;a href=&#39;#path/to/foo.c/one-link&#39;&gt;one link&lt;/a&gt;
&lt;a href=&#39;#path/to/bar.c/another-link&#39;&gt;another link&lt;/a&gt;
</code></pre>
<a id='src/story/core.clj/link-renderer'></a>
<pre class='brush: clojure'>(def link-renderer
  ; "A pegdown LinkRenderer that renders wiki links as links to internal
  ; document fragments rather than external HTML pages."
  (letfn [(def-name [s] (re-find #"(?&lt;=/)[^/]+$" s))
          (anchor-name [s]
            (html-escape (or (def-name s) s)))]
    (proxy [LinkRenderer] []
      (render
        ([node]
         (if-let [text (and (instance? WikiLinkNode node)
                            (.getText node))]
           (try
             (LinkRenderer$Rendering.
                           (str
                             "#"
                             (normalize-anchor text))
                           (anchor-name text))
             (catch java.io.UnsupportedEncodingException _
               (throw (IllegalStateException.))))
           (proxy-super render node)))
        ([node text]
         (proxy-super render node text))
        ([node url title text]
         (proxy-super render node url title text))))))

</pre>
<a id='src/story/core.clj/Utilities'></a>
<h2>Utilities</h2><p>A few utility functions to make it easier to print messages to the console, iterate side-effects through a collection, access resources, encode a string for use as an id or fragment identifier, and bind an output stream to <code>*out*</code> over a lexical scope.</p>
<a id='src/story/core.clj/cond-let'></a>
<pre class='brush: clojure'>(defmacro cond-let
  "Takes a binding-form and a set of test/expr pairs. Evaluates each test one
  at a time. If a test returns logical true, cond-let evaluates and returns
  expr with binding-form bound to the value of test and doesn't evaluate any of
  the other tests or exprs. To provide a default value either provide a literal
  that evaluates to logical true and is binding-compatible with binding-form,
  or use :else as the test and don't refer to any parts of binding-form in the
  expr. (cond-let binding-form) returns nil."
  [bindings &amp; clauses]
  (let [binding (first bindings)]
    (when-let [[test expr &amp; more] clauses]
      (if (= test :else)
        expr
        `(if-let [~binding ~test]
           ~expr
           (cond-let ~bindings ~@more))))))
</pre>
<a id='src/story/core.clj/message'></a>
<pre class='brush: clojure'>(defn message
  "Write s to standard error."
  [&amp; s]
  (when (:verbose? *settings*)
    (binding [*out* (io/writer System/err)]
      (println (apply str s)))))
</pre>
<a id='src/story/core.clj/each'></a>
<pre class='brush: clojure'>(defn each
  "Apply f to each item of coll in order for side effects only. Evaluates coll
  strictly, unlike for. Returns nil."
  [f coll]
  (doseq [c coll]
    (f c)))
</pre>
<a id='src/story/core.clj/lazy-each'></a>
<pre class='brush: clojure'>(defn lazy-each
  ""
  [f coll]
  (lazy-seq
    (when (seq coll)
      (cons (f (first coll)) (lazy-each f (rest coll))))))
</pre>
<a id='src/story/core.clj/slurp-resource'></a>
<pre class='brush: clojure'>(defn slurp-resource
  "Get the complete contents of a Java resource. Throws an exception on
  failure unless continue-on-failure? is truthy."
  [resource-name &amp; continue-on-failure?]
  (try
    (-&gt; (.getContextClassLoader (Thread/currentThread))
      (.getResourceAsStream resource-name)
      (java.io.InputStreamReader.)
      (slurp))
    (catch Exception e
      (message "Failed to read resource " resource-name)
      (if continue-on-failure?
        (message "    continuing anyway...")
        (do (message "    aborting...")
          (throw e))))))
</pre>
<a id='src/story/core.clj/slurp-file|resource'></a>
<pre class='brush: clojure'>(defn slurp-file|resource
  "Get the contents of the file at path, or failing that, the contents of a
  Java resource. Throws an exception on failure unless continue-on-failure? is
  truthy."
  [path &amp; continue-on-failure?]
  (try (slurp path)
    (catch java.io.FileNotFoundException _
      (message "Using internal " path)
      (slurp-resource path continue-on-failure?))))
</pre>
<a id='src/story/core.clj/encode-anchor'></a>
<pre class='brush: clojure'>(defn encode-anchor
  "Encode s for use as a fragment identifier."
  [s]
  (.replaceAll
    (if (some #{\/} s) s (str *path* "/" s))
    "\\s" "-"))
</pre>
<a id='src/story/core.clj/normalize-anchor'></a>
<pre class='brush: clojure'>(defn normalize-anchor
  [s]
  "Encode s using encode-anchor and ensure it is qualified by file path."
  (encode-anchor (if (some #{\/} s) s (str *path* "/" s))))
</pre>
<a id='src/story/core.clj/html-escape'></a>
<pre class='brush: clojure'>(defn html-escape
  "Escape s for inclusion in HTML."
  [s]
  (string/escape
    s
    {\&lt; "&amp;lt;"
     \&gt; "&amp;gt;"
     \&amp; "&amp;amp;"}))

</pre>
<a id='src/story/core.clj/IO-helpers'></a>
<h3>IO helpers</h3>
<a id='src/story/core.clj/with-out-stream'></a>
<pre class='brush: clojure'>(defmacro with-out-stream
  "Wrap an output stream using clojure.java.io/writer bind it to *out*, then
  execute body."
  [out &amp; body]
  `(with-open [w# (io/writer ~out)]
     (binding [*out* w#]
       ~@body)))
</pre>
<a id='src/story/core.clj/read-lines'></a>
<pre class='brush: clojure'>(defn read-lines
  "Like clojure.core/line-seq but opens r with reader.  Automatically
  closes the reader AFTER YOU CONSUME THE ENTIRE SEQUENCE."
  [r]
  (let [read-line (fn this [^BufferedReader rdr]
                    (lazy-seq
                      (if-let [line (.readLine rdr)]
                        (cons line (this rdr))
                        (.close rdr))))]
    (read-line (io/reader r))))
</pre>
<a id='src/story/core.clj/write-lines'></a>
<pre class='brush: clojure'>(defn write-lines
  "Writes lines (a seq) to f, separated by newlines.  f is opened with
  writer, and automatically closed at the end of the sequence."
  [w lines]
  (with-open [^BufferedWriter writer (io/writer w)]
    (loop [lines lines]
      (when-let [line (first lines)]
        (.write writer (str line))
        (.newLine writer)
        (recur (rest lines))))))
</pre>
<a id='src/story/core.clj/map-lines'></a>
<pre class='brush: clojure'>(defn map-lines
  ""
  [r w f]
  (write-lines w (map f (read-lines r))))

</pre>
<a id='src/story/core.clj/SyntaxHighlighter-language-helpers'></a>
<h3>SyntaxHighlighter language helpers</h3>
<a id='src/story/core.clj/canonical-lang'></a>
<pre class='brush: clojure'>(defn canonical-lang
  "Given a language keyword, return its canonical equivalent."
  [l]
  (let [k (keyword l)]
    (get language-aliases k k)))
</pre>
<a id='src/story/core.clj/lang-info'></a>
<pre class='brush: clojure'>(defn lang-info
  "Given a language keyword, return its information as a vector pair of
  comment syntax and SyntaxHighlighter brush name."
  [l]
  (languages (canonical-lang l)))
</pre>
<a id='src/story/core.clj/lang-comment'></a>
<pre class='brush: clojure'>(defn lang-comment
  "Given a language keyword, return its comment syntax."
  [l]
  (first (lang-info l)))
</pre>
<a id='src/story/core.clj/lang-brush'></a>
<pre class='brush: clojure'>(defn lang-brush
  "Given a language keyword, return its default SyntaxHighlighter brush name."
  [l]
  (second (lang-info l)))

</pre>
<a id='src/story/core.clj/Regular-expression-helpers'></a>
<h3>Regular expression helpers</h3>
<a id='src/story/core.clj/?match'></a>
<pre class='brush: clojure'>(defn ?match [s reg]
  (when-let [m (re-find (reg) s)]
    (.substring s (count m))))
</pre>
<a id='src/story/core.clj/comment'></a>
<pre class='brush: clojure'>(defn comment
  "A regular expression matching the beginning of a commented line."
  []
  (re-pattern (str "^\\s*" (Pattern/quote *single-comment*))))
</pre>
<a id='src/story/core.clj/markdown*'></a>
<pre class='brush: clojure'>(defn markdown*
  ""
  []
  (if (= :markdown (canonical-lang *language*))
    (comment)
    (re-pattern (str (comment) " "))))
</pre>
<a id='src/story/core.clj/markdown'></a>
<pre class='brush: clojure'>(defn markdown
  ""
  []
  (re-pattern (str (markdown*) "|" (comment) "$")))
</pre>
<a id='src/story/core.clj/hidden-comment'></a>
<pre class='brush: clojure'>(defn hidden-comment
  "A regular expression matching the beginning of a commented line that will
  not appear in the output."
  []
  (re-pattern (str (comment) ".")))
</pre>
<a id='src/story/core.clj/anchor'></a>
<pre class='brush: clojure'>(defn anchor
  "A regular expression matching the beginning of an anchor line."
  []
  (re-pattern (str (comment) "@ *")))
</pre>
<a id='src/story/core.clj/heading'></a>
<pre class='brush: clojure'>(defn heading
  "A regular expression matching the beginning of a heading line."
  []
  (re-pattern (str (markdown*) "\\#+ *")))
</pre>
<a id='src/story/core.clj/include'></a>
<pre class='brush: clojure'>(defn include
  "A regular expression matching the beginning of an include line."
  []
  (re-pattern (str (comment) "%include +")))
</pre>
<a id='src/story/core.clj/required'></a>
<pre class='brush: clojure'>(defn required
  "A regular expression matching the beginning of a require line."
  []
  (re-pattern (str (comment) "%require +")))
</pre>
<a id='src/story/core.clj/begin-test'></a>
<pre class='brush: clojure'>(defn begin-test
  "A regular expression matching the beginning of a test section."
  []
  (re-pattern (str (comment) "&lt;\\?")))
</pre>
<a id='src/story/core.clj/end-test'></a>
<pre class='brush: clojure'>(defn end-test
  "A regular expression matching the end of a test section."
  []
  (re-pattern (str (comment) "\\?&gt;")))
</pre>
<a id='src/story/core.clj/begin-hidden'></a>
<pre class='brush: clojure'>(defn begin-hidden
  "A regular expression matching the beginning of a hidden section."
  []
  (re-pattern (str (comment) "&lt;\\.")))
</pre>
<a id='src/story/core.clj/end-hidden'></a>
<pre class='brush: clojure'>(defn end-hidden
  "A regulare expression matching the end of a hidden section."
  []
  (re-pattern (str (comment) "\\.&gt;")))

</pre>
<a id='src/story/core.clj/Parsing'></a>
<h2>Parsing</h2><p>Parsing is done by looping through a lazy list of lines. A character stream backed by that lazy list is used when reading across lines is necessary. See the <code>:else</code> case in <a href="#src/story/core.clj/classify-line">classify-line</a> and <a href="#src/story/core.clj/code-anchor-id-:clojure">code-anchor-id :clojure</a> for an example.</p><p>The entry-point for parsing is the <a href="#src/story/core.clj/gather-lines">gather-lines</a> function at the end of this section.</p>
<a id='src/story/core.clj/lines-reader'></a>
<pre class='brush: clojure'>(defn lines-reader [lines]
  (let [lines-left (atom (interpose "\n" (filter seq lines)))]
    (java.io.PushbackReader.
      (proxy [java.io.Reader] []
        (close [])
        (read
</pre>
<p>The clojure reader only calls the zero arity read method. Punting on implementing the other arities for now.</p>
<pre class='brush: clojure'>          ([]
           (let [ll @lines-left
                 line (first ll)
                 c (first line)]
             (reset! lines-left
                     (if (seq (rest line))
                       (cons (subs line 1) (rest ll))
                       (rest ll)))
             (if c (int c) -1))))))))
</pre>
<p>Anchors for definitions are generated using the current line and a reader from the current line. Methods are expected to return a string identifying the definition, or <code>nil</code> if there is no definition beginning at the current line. The default method unconditionally returns <code>nil</code>.</p>
<a id='src/story/core.clj/code-anchor-id'></a>
<pre class='brush: clojure'>(defmulti code-anchor-id
  "If the current line (or reader) begins a definition, return the definition
  name, otherwise return nil."
  (fn [line reader] *language*)
  :default :default)
</pre>
<a id='src/story/core.clj/code-anchor-id-:default'></a>
<pre class='brush: clojure'>(defmethod code-anchor-id :default [_ _] nil)
</pre>
<p>The clojure method uses the clojure reader, which should be more robust than methods which use regular expressions.</p>
<a id='src/story/core.clj/code-anchor-id-:clojure'></a>
<pre class='brush: clojure'>(defmethod code-anchor-id :clojure [line reader]
  (when (re-find #"^\(" line)
    (let [code (read reader)]
      (cond
        (= 'defmethod (first code))
        (str (second code) " " (nth code 2))

        (re-find #"^def" (str (first code)))
        (name (second code))

        :else nil))))
</pre>
<p>Not all of these methods are well tested, like this javascript one.</p>
<a id='src/story/core.clj/code-anchor-id-:javascript'></a>
<pre class='brush: clojure'>(defmethod code-anchor-id :javascript [line reader]
  (or (second (re-find #"^\s*function\s+([^\s\(]+)" line))
      (second (re-find #"^var\s+([A-Za-z_][A-Za-z_0-9]*)\s*=\s*function[\s\(]" line))
      (second (re-find #"^\s*'?([A-Za-z_][A-Za-z_0-9]*)'?\s*:\s*function[\s\(]" line))))
</pre>
<a id='src/story/core.clj/code-anchor-id-:vim'></a>
<pre class='brush: clojure'>(defmethod code-anchor-id :vim [line reader]
  (second (re-find #"^function!?\s+([a-zA-Z_][a-zA-Z_0-9]*)" line)))
</pre>
<p>The line parser emits a list of <code>[&lt;classification&gt; &lt;data&gt;]</code> pairs. This function calls <a href="#src/story/core.clj/code-anchor-id">code-anchor-id</a> and returns an <code>[:anchor &lt;id&gt;]</code> pair. It also stores the anchor information for future use by <a href="#src/story/core.clj/code-anchor-toc">code-anchor-toc</a>, which generates a table of contents for definitions with anchors.</p>
<a id='src/story/core.clj/maybe-code-anchor'></a>
<pre class='brush: clojure'>(defn maybe-code-anchor
  "If the current line (or reader) begins a definition, store the definition
  name in *code-anchors* with the current file path as its key. Return the
  path qualified id, or return nil."
  [line reader]
  (if-let [id (code-anchor-id line reader)]
    (do
      (swap! *code-anchors*
             (fn [old]
               (update-in old [*path*] #(conj (or % []) id))))
      [[:anchor (str *path* "/" id)]])
    []))
</pre>
<a id='src/story/core.clj/include-info'></a>
<pre class='brush: clojure'>(defn include-info
  ""
  [s]
  (let [[path &amp; [token lang]] (string/split s #"\s+")
        lang (canonical-lang (or lang
                                 (re-find #"(?&lt;=\.)[^/.]+$" path)
                                 *language*))
        comment (or token
                    (lang-comment (or lang *language*))
                    *single-comment*)]
    [path comment lang]))
</pre>
<p>Each line of a source file will be either code, comment, anchor, include, or test code. Headings are treated as both anchors and comments.</p>
<a id='src/story/core.clj/classify-line'></a>
<pre class='brush: clojure'>(defn classify-line
  "Classify the first line in lines. Commented lines prefixed by white space
  are ignored. Returns a vector containing a single pair of the form
  [&lt;classification&gt; &lt;data&gt;], where &lt;data&gt; is a string except in the case of an
  include where it is a vector of [&lt;path&gt; &amp; [&lt;comment-syntax&gt; &lt;language&gt;]]."
  [[line :as lines]]
  (let [m (partial ?match line)]
    (cond-let
      [text]
      (m include) [[:include (include-info text)]]
      (m required) []
      (m begin-test) [[:begin-test text]]
      (m end-test) [[:end-test text]]
      (m begin-hidden) [[:begin-hidden text]]
      (m end-hidden) [[:end-hidden text]]
      (m anchor) [[:anchor text]]
      (m heading) [[:anchor text]
                   [:comment (m markdown)]]
      (m markdown) [[:comment text]]
      (m hidden-comment) []
      :else (conj (maybe-code-anchor line (lines-reader lines))
                  [:code line]))))
</pre>
<p>Each line is classified lazily.</p>
<a id='src/story/core.clj/classify-lines'></a>
<pre class='brush: clojure'>(defn classify-lines
  "Classify each line in lines as :code, :comment, :anchor, or :include.
  Returns a lazy list of [&lt;classification&gt; &lt;data&gt;] pairs. See classify-line for
  more detail."
  [lines]
  (lazy-seq
    (when (seq lines)
      (concat (classify-line lines) (classify-lines (rest lines))))))
</pre>
<p>Adjacent lines of the same classification need to be gathered together into a single string (except for anchors and includes).</p>
<a id='src/story/core.clj/gather-lines-'></a>
<pre class='brush: clojure'>(defn gather-lines-
  [lines]
  (lazy-seq
    (when-let [classfn (first (first lines))]
      (cond
        (#{:comment :code} classfn)
        (let [[same tail] (split-with #(= classfn (first %)) lines)
              text (string/join "\n" (map second same))]
          (cons [classfn text] (gather-lines- tail)))

        (= :begin-hidden classfn)
        (gather-lines-
          (rest (drop-while
                  #(not= :end-hidden (first %))
                  (rest lines))))

        :else
        (cons (first lines) (gather-lines- (rest lines)))))))
</pre>
<p>The entry-point for parsing is this <code>gather-lines</code> function.</p>
<a id='src/story/core.clj/gather-lines'></a>
<pre class='brush: clojure'>(defn gather-lines
  "Join adjacent strings of the same classification together (except :anchor
  and :include). Return a lazy list of [&lt;classification&gt; &lt;data&gt;] pairs. See
  classify-line for more detail."
  [lines]
  (gather-lines- (classify-lines lines)))

</pre>
<a id='src/story/core.clj/Rendering'></a>
<h2>Rendering</h2><p>The method that transforms each classified chunk into HTML, dispatches on the classification of each item in the list returned by <a href="#src/story/core.clj/gather-lines">gather-lines</a>.</p>
<a id='src/story/core.clj/html<-'></a>
<pre class='brush: clojure'>(defmulti html&lt;- first)
</pre>
<p>SyntaxHighlighter brushes are associated with files if the language is supplied or can be worked out from the file suffix.</p>
<a id='src/story/core.clj/maybe-associate-brush'></a>
<pre class='brush: clojure'>(defn maybe-associate-brush [path lang]
  (when-let [b (and lang (lang-brush lang))]
    (when-not (@*brushes* b)
      (message "Associating "path " with brush " b)
      (swap! *brushes* conj b))))
</pre>
<p>The output of each file is wrapped in <code>article</code> or <code>section</code> tags. Article tags for top-level files and section tags for included ones.</p>
<a id='src/story/core.clj/wrap-in-tags'></a>
<pre class='brush: clojure'>(defmacro wrap-in-tags [tag &amp; body]
  `(do
     (print ~tag)
     ~@body
     (print (str "&lt;/" (re-find #"(?&lt;=^&lt;)[^\s&gt;]+" ~tag) "&gt;"))))
</pre>
<a id='src/story/core.clj/render-file'></a>
<pre class='brush: clojure'>(defn render-file [tag path &amp; [token lang]]
</pre>
<p>For each file, new bindings are made for comment syntax and language. If the language or comment syntax (<code>token</code>) are not supplied, they are guessed from the <code>path</code> suffix, and if that fails they are set to the values they have in the enclsing dynamic scope (i.e., from the commandline or the including file).</p>
<pre class='brush: clojure'>  (binding [*language* (canonical-lang
                         (or lang
                             (re-find #"(?&lt;=\.)[^/.]+$" path)
                             *language*))]
    (binding [*single-comment* (or token
                                   (lang-comment *language*)
                                   *single-comment*)]
      (binding [*path* path]
        (wrap-in-tags
          tag
          (when-not (= :markdown (canonical-lang *language*))
            (maybe-associate-brush path *language*))
</pre>
<p>Lines of source code are read lazily by <code>line-seq</code> and gathered lazily by <code>gather-lines</code>, Along with printing each chunk of comment or code to an output stream, this ensures that the maximum memory used by this program will be determined by the largest comment or code chunk and not the total size of the source file.</p>
<pre class='brush: clojure'>          (each html&lt;- (gather-lines (read-lines path))))))))
</pre>
<p>Code chunks are wrapped in a <code>pre</code> with the correct incantation for SyntaxHighlighter in its <code>class</code> attribute; comments are run through the Markdown processor; anchors become hrefless HTML anchors; and includes wrap the result of parsing and rendering the file they point to in <code>section</code> tags.</p>
<a id='src/story/core.clj/html<--:code'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :code [[_ text]]
  (when-not (string/blank? text)
    (println (str "&lt;pre class='brush: " (name *language*) "'&gt;"
                  (html-escape text)
                  "&lt;/pre&gt;"))))
</pre>
<a id='src/story/core.clj/html<--:comment'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :comment [[_ text]]
  (println (.markdownToHtml processor text link-renderer)))
</pre>
<a id='src/story/core.clj/html<--:anchor'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :anchor [[_ text]]
  (println (str "&lt;a id='" (normalize-anchor text) "'&gt;&lt;/a&gt;")))
</pre>
<a id='src/story/core.clj/html<--:include'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :include [[_ [path comment lang] :as args]]
  (render-file "&lt;section&gt;" path comment lang))
</pre>
<a id='src/story/core.clj/html<--:begin-test'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :begin-test [_]
  (println "&lt;div class='test'&gt;"))
</pre>
<a id='src/story/core.clj/html<--:end-test'></a>
<pre class='brush: clojure'>(defmethod html&lt;- :end-test [_]
  (println "&lt;/div&gt;"))

</pre>
<a id='src/story/core.clj/Look-and-feel'></a>
<h2>Look and feel</h2><p>A TOC is created for code anchors.</p>
<a id='src/story/core.clj/code-anchor-toc'></a>
<pre class='brush: clojure'>(defn code-anchor-toc []
  (wrap-in-tags "&lt;div id='code-anchors'&gt;"
    (wrap-in-tags "&lt;ul&gt;"
      (doseq [[path ids] (reverse @*code-anchors*)]
        (wrap-in-tags "&lt;li&gt;"
          (print (str path "&lt;br&gt;"))
          (wrap-in-tags "&lt;ul&gt;"
            (doseq [id (sort ids)]
              (wrap-in-tags "&lt;li&gt;"
                (wrap-in-tags (str "&lt;a href='#"
                                   (encode-anchor (str path "/" id))
                                   "'&gt;")
                  (print (html-escape id)))))))))))
</pre>
<p>All javascript and CSS are inlined in the output.</p>
<a id='src/story/core.clj/inline-js'></a>
<pre class='brush: clojure'>(defn inline-js [s]
  (println "&lt;script&gt;" s "&lt;/script&gt;"))
</pre>
<a id='src/story/core.clj/inline-css'></a>
<pre class='brush: clojure'>(defn inline-css [s]
  (println "&lt;style&gt;" s "&lt;/style&gt;"))
</pre>
<p>SyntaxHighlighter brushes can be set and the default theme (<code>shThemeEclipse.css</code>) overridden on the commandline. An additional stylesheet can also be set.</p><p>Because lack of brush or theme will not materially affect the structure of the output page, failure to load one or more of them will not cause the program to halt, though it will be logged to standard-error.</p>
<a id='src/story/core.clj/inline-brushes'></a>
<pre class='brush: clojure'>(defn inline-brushes []
  (message "Adding the following brushes to output:")
  (each (partial message "    ") @*brushes*)
  (each inline-js
        (filter identity
                (map #(slurp-file|resource % :continue-on-failure)
                     @*brushes*))))
</pre>
<a id='src/story/core.clj/inline-theme'></a>
<pre class='brush: clojure'>(defn inline-theme []
  (when-let [s (and (:theme *settings*)
                    (slurp-file|resource
                      (:theme *settings*)
                      :continue-on-faliure))]
    (inline-css s)))
</pre>
<a id='src/story/core.clj/inline-stylesheet'></a>
<pre class='brush: clojure'>(defn inline-stylesheet []
  (when-let [s (and (:stylesheet *settings*)
                    (slurp-file|resource
                      (:stylesheet *settings*)
                      :continue-on-failure))]
    (inline-css s)))
</pre>
<p>The resulting look-and-feel resources are included together.</p>
<a id='src/story/core.clj/look-and-feel'></a>
<pre class='brush: clojure'>(defn look-and-feel []
  (inline-js (slurp-resource "XRegExp.js"))
  (inline-js (slurp-resource "shCore.js"))
  (inline-theme)
  (inline-js (slurp-resource "outliner.0.5.0.62.js"))
  (inline-css (slurp-resource "page.css"))
  (inline-stylesheet))
</pre>
<p>Javascript configuration and entry-point for SyntaxHighlighter and TOC outline are included from an external resource.</p>
<a id='src/story/core.clj/javascript-setup'></a>
<pre class='brush: clojure'>(defn javascript-setup []
  (inline-js (slurp-resource "page.js")))

</pre>
<a id='src/story/core.clj/Output'></a>
<h2>Output</h2><p>The output is HTML5 which is why no <code>html</code>, <code>head</code>, or <code>body</code> tags are present. The order of things in the output file is fairly normal for HTML: style and behaviour information first, followed by visible content, followed by the javascript entry-point.</p>
<a id='src/story/core.clj/render-files-'></a>
<pre class='brush: clojure'>(defn render-files- [paths]
  (println
    "&lt;!doctype html&gt;"
    "&lt;meta charset=utf-8&gt;")
  (look-and-feel)
</pre>
<p>Multiple input files are rendered to a single stream. The content of each file&rsquo;s rendering is wrapped in its own <code>article</code> tags.</p>
<pre class='brush: clojure'>  (each (partial render-file "&lt;article&gt;") paths)
  (code-anchor-toc)
  (inline-brushes)
  (javascript-setup))
</pre>
<a id='src/story/core.clj/render-files'></a>
<pre class='brush: clojure'>(defn render-files [paths]
</pre>
<p><a href="#src/story/core.clj/*brushes*">*brushes*</a> and <a href="#src/story/core.clj/*code-anchors*">*code-anchors*</a> are rebound on every invocation of <code>render-files</code> to prevent unneeded brushes and anchors accumulating across calls.</p>
<pre class='brush: clojure'>  (binding [*brushes* (atom (or (set (:static-brushes *settings*)) #{})
                            :validator #(not (some (comp not string?) %)))
            *code-anchors* (atom (array-map))]
    (render-files- paths)))
</pre>
<p>The program entry-point takes a list of paths to input files and a single output stream which can also be a file path or anything <code>clojure.java.io/writer</code> can handle.</p>
<a id='src/story/core.clj/process-files'></a>
<pre class='brush: clojure'>(defn process-files
  "Take a list of file paths and an output stream, and render each file to the
  stream as HTML."
  [in-paths out]
  (when-let [d (and
                 (or (string? out)
                     (instance? java.io.File out))
                 (fs/dirname out))]
    (fs/mkdirs d))
  (with-out-stream out
    (render-files in-paths)))

</pre>
<a id='src/story/core.clj/Testing'></a>
<h2>Testing</h2><p>Code that is wrapped in test tags <code>;&lt;?</code> and <code>;?&gt;</code>, where <code>;</code> is the comment syntax for the file, will be included in the output by default and wrapped in a <code>div</code> with the class <code>test</code>. To get a production tree without tests, run this program with the <code>--production</code> flag with a directory argument, or call <a href="#src/story/core.clj/write-production-tree">write-production-tree</a>.</p><p>To include files in the production tree but not in the documentation, use <code>;%require &lt;file or directory&gt;</code>, replacing <code>;</code> with the correct comment token.</p>
<a id='src/story/core.clj/write-production-file'></a>
<pre class='brush: clojure'>(defn write-production-file
  "Write in-file to outdir with all test code commented (thus preserving line
  numbers)."
  [in-file outdir]
  (let [out-file (io/file outdir in-file)
        in-test? (atom false)]
    (.. out-file (getParentFile) (mkdirs))
    (map-lines
      in-file out-file
      (fn [line]
        (let [m (partial ?match line)]
          (cond-let
            [text]
            (m begin-test)
            (do (reset! in-test? true)
              line)

            (m end-test)
            (do (reset! in-test? false)
              line)

            :else
            (if @in-test?
              (str *single-comment* line)
              (cond-let
                [text]
                (m include)
                (let [[path comment lang] (include-info text)]
                  (binding [*path* path]
                    (binding [*single-comment* comment]
                      (binding [*language* lang]
                        (write-production-file path outdir))))
                  line)

                (m required)
                (do (if (fs/directory? text)
                      (fs/copy-tree text (io/file outdir (or (fs/dirname text) "")))
                      (fs/copy+ text (io/file outdir text)))
                  line)

                :else line))))))))

</pre>
<a id='src/story/core.clj/Entry-points'></a>
<h2>Entry points</h2><p>There are two entry functions and one <a href="#src/story/core.clj/-main">-main</a> function for commandline use.</p><p>The first entry function is for writing a production tree (all required files sans test sections).</p>
<a id='src/story/core.clj/write-production-tree'></a>
<pre class='brush: clojure'>(defn write-production-tree
  "Write the contents of in-paths with recursive included and required files
  and directories to outdir, with any test code commented."
  [in-paths outdir]
  (when (fs/exists? outdir)
    (fs/deltree outdir))
  (fs/mkdirs outdir)
  (doseq [p in-paths]
    (write-production-file p outdir)))
</pre>
<p>The second entry function is for building documentation. It takes a map of options, an output file, and a list of files to process. The options are all optional but at least one input file must be provided.</p><p>The options are:</p>
<pre><code>:comment     String           single line comment syntax
:brushes     ISeq of Strings  paths to SyntaxHighlighter brush files
:theme       String           path to a SyntaxHighlighter theme file
:language    String           SyntaxHighlighter language name
:stylesheet  String           path to a CSS file
:verbose     boolean          whether to use verbose output
</code></pre><p>For the brush, theme, and stylesheet options the program first tries to read from the filesystem and if that fails because the file is not found then an attempt is made to read from the program&rsquo;s resources. The resources contain the standard SyntaxHighlighter brushes and themes under their normal file names including an additional <code>shBrushClojure.js</code> and <code>shThemeClojure.css</code>.</p><p>Additional brushes may be added by the program as a result of file includes and file suffixes.</p>
<a id='src/story/core.clj/story'></a>
<pre class='brush: clojure'>(defn story [opts out-file &amp; in-files]
  (binding [*settings* {:theme (or (:theme opts) (:theme *settings*))
                        :stylesheet (:stylesheet opts)
                        :static-brushes (:brush opts)
                        :verbose? (:verbose opts)}]
    (binding [*single-comment* (or (:comment opts) *single-comment*)]
      (binding [*language* (canonical-lang (or (:language opts) *language*))]
          (process-files in-files out-file)))))
</pre>
<section><a id='src/story/main.clj/Commandline'></a>
<h1>Commandline</h1>
<pre class='brush: clojure'>(ns story.main
  (:refer-clojure :exclude (comment))
  (:use
    story.core)
  (:require
    [clojure.tools.cli :as cli])
</pre>
<p>To run from the commandline this namespace must be compiled with a <code>-main</code> method.</p>
<pre class='brush: clojure'>  (:gen-class))
</pre>
<p>Use this program from the commandline like so.</p>
<a id='src/story/main.clj/usage'></a>
<pre class='brush: clojure'>(def usage "Usage: java -jar story.jar [options] &lt;input-files&gt;")
</pre>
<a id='src/story/main.clj/-main'></a>
<pre class='brush: clojure'>(defn -main [&amp; args]
  (let [[amap tail banner]
        (cli/cli args
</pre>
<p>Here is a list of the options this program can take when run from the commandline.</p>
<pre class='brush: clojure'>                 ["-c" "--comment" "Comment syntax"]
                 ["-b" "--brush" "SyntaxHighlighter brush file" :multi true]
                 ["-t" "--theme" "SyntaxHighlighter theme file"]
                 ["-l" "--language" "SyntaxHighlighter language"]
                 ["-s" "--stylesheet" "A stylesheet file to include"]
                 ["-p" "--production" "Production directory."]
                 ["-v" "--verbose" "Turn on verbose output"
                  :default false :flag true]
                 ["-h" "--help" "Show this help" :default false :flag true])]
</pre>
<p>Multiple brushes can be used by repeating the <code>-b</code> or <code>--brush</code> options.</p><p>If present, the <code>-p</code> or <code>--production</code> option prevents documentation generation, and instead writes a production tree to the supplied directory using <a href="#src/story/main.clj/write-production-tree">write-production-tree</a>.</p>
<pre class='brush: clojure'>
    (if (or (not (seq tail)) (:help amap))
      (do (println (str usage "\n" banner))
        (System/exit 1))
      (if-let [dir (:production amap)]
        (write-production-tree tail dir)
</pre>
<p>When no output file is given, the program renders to standard-out.</p>
<pre class='brush: clojure'>        (if (= 1 (count tail))
          (apply story amap *out* tail)
          (apply story amap (last tail) (butlast tail)))))))</pre>
</section></section><section><a id='resources/page.js/Javascript-setup'></a>
<h1>Javascript setup</h1><p>This setup code is placed in a function purely to test/show-off story&rsquo;s anchor generation.</p>
<a id='resources/page.js/me_panzoo_story_setup'></a>
<pre class='brush: javascript'>function me_panzoo_story_setup() {
</pre>
<p>SyntaxHighlighter&rsquo;s defaults are not suitable, so they are tweaked.</p>
<pre class='brush: javascript'>  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.defaults['smart-tabs'] = false;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['unindent'] = false;
  SyntaxHighlighter.defaults['class-name'] = 'code';
  SyntaxHighlighter.all();
</pre>
<p><a href="http://code.google.com/p/h5o/">h50</a>, the HTML5 outliner is used to create a table of contents.</p>
<pre class='brush: javascript'>  var outline = document.createElement('div');
  outline.setAttribute('id', 'outline');
  outline.innerHTML = HTML5Outline(document.body).asHTML(true);
  var children = outline.firstElementChild.firstElementChild.children;
  outline.removeChild(outline.firstElementChild);
  for (var i = 1; i &lt; children.length; ++i) {
    outline.appendChild(children[i]);
  }
  document.body.appendChild(outline);

  var h1s = document.getElementsByTagName('h1');
  if (h1s.length &gt; 0) document.title = h1s[0].innerText;
</pre>
<p>Test code is hidden by default.</p>
<pre class='brush: javascript'>  var makeToggle = function(test) {
    var x = document.createElement('div');
    x.setAttribute('class', 'test-toggle');
    x.style.display = 'block';
    x.innerText = '?';
    x.onclick = function() {
      if (test.style.display == 'none') {
        test.style.display = 'block';
      } else {
        test.style.display = 'none';
      }
    };
    return x;
  };
  var tests = document.querySelectorAll('div.test');
  for (var i = 0; i &lt; tests.length; ++i) {
    console.log('test', i, tests[i]);
    var test = tests[i];
    var tog = makeToggle(test);
    test.style.display = 'none';
    test.parentNode.insertBefore(tog, test);
  }
</pre>
<p>A master toggle is created if there is more than one test section.</p>
<pre class='brush: javascript'>  if (tests.length &gt; 1) {
    var masterTog = document.createElement('div');
    masterTog.setAttribute('id', 'master-toggle');
    masterTog.innerText = '? show all';
    masterTog.onclick = function() {
      var show = masterTog.innerText == '? show all';
      var display = show ? 'block' : 'none';
      masterTog.innerText = show ? '? hide all' : '? show all';
      for (var i = 0; i &lt; tests.length; ++i) {
        tests[i].style.display = display;
      }
    };
    var e = document.querySelector('h1').nextSibling;
    e.parentNode.insertBefore(masterTog, e);
  }
}

me_panzoo_story_setup();</pre>
</section><section><a id='folding.vim/Code-folding-for-Vim'></a>
<h1>Code folding for Vim</h1><p>Add this code to your <code>~/.vimrc</code> to enable folding of Markdown files and source files with Markdown comments.</p><p>The fold level is determined by the number of <code>#</code> at the start of each heading. Underlined headings are not supported.</p><p>Test code is also made foldable.</p>
<a id='folding.vim/MarkdownLevel'></a>
<pre class='brush: vim'>function! MarkdownLevel(token)
  if 0 == empty(matchstr(getline(v:lnum), '^'.a:token.'&lt;\(?\|\.\)'))
    return 'a1'
  endif
  if 0 == empty(matchstr(getline(v:lnum), '^'.a:token.'\(?\|\.\)&gt;'))
    return 's1'
  endif
  let level = strlen(matchstr(getline(v:lnum),
        \                     '\(^'.a:token.' \)\@&lt;=#\+\( \)\@='))
  if level == 0
    return "="
  else
    return "&gt;".level
  endif
endfunction
</pre>
<p>Different comment tokens are supported.</p>
<pre class='brush: vim'>let g:comment#none = ''
let g:comment#semi = ';;'
let g:comment#slashes = '//'
let g:comment#hash = '#'
let g:comment#dblquote = '"'

au BufEnter *.md,*.clj,*.cljs,*.js,*.sh setlocal foldmethod=expr
</pre>
<p>I don&rsquo;t know why passing a string literal to <code>MarkdownLevel</code> doesn&rsquo;t work here. Vimscript is not my forte.</p>
<pre class='brush: vim'>au BufEnter *.md setlocal foldexpr=MarkdownLevel(comment#none)
au BufEnter *.clj,*.cljs setlocal foldexpr=MarkdownLevel(comment#semi)
au BufEnter *.js setlocal foldexpr=MarkdownLevel(comment#slashes)
au BufEnter *.sh setlocal foldexpr=MarkdownLevel(comment#hash)
au BufEnter *.vim setlocal foldexpr=MarkdownLevel(comment#dblquote)

</pre>
<a id='folding.vim/Key-bindings'></a>
<h2>Key bindings</h2><p><code>za</code> toggle current fold<br/><code>zR</code> open all folds<br/><code>zM</code> close all folds<br/><code>zr</code> open one more level of folds<br/><code>zm</code> close one more level of folds </p>
</section></article><div id='code-anchors'><ul><li>project.clj<br><ul><li><a href='#project.clj/story'>story</a></li></ul></li><li>src/story/core.clj<br><ul><li><a href='#src/story/core.clj/*brushes*'>*brushes*</a></li><li><a href='#src/story/core.clj/*code-anchors*'>*code-anchors*</a></li><li><a href='#src/story/core.clj/*language*'>*language*</a></li><li><a href='#src/story/core.clj/*path*'>*path*</a></li><li><a href='#src/story/core.clj/*settings*'>*settings*</a></li><li><a href='#src/story/core.clj/*single-comment*'>*single-comment*</a></li><li><a href='#src/story/core.clj/?match'>?match</a></li><li><a href='#src/story/core.clj/anchor'>anchor</a></li><li><a href='#src/story/core.clj/begin-hidden'>begin-hidden</a></li><li><a href='#src/story/core.clj/begin-test'>begin-test</a></li><li><a href='#src/story/core.clj/canonical-lang'>canonical-lang</a></li><li><a href='#src/story/core.clj/classify-line'>classify-line</a></li><li><a href='#src/story/core.clj/classify-lines'>classify-lines</a></li><li><a href='#src/story/core.clj/code-anchor-id'>code-anchor-id</a></li><li><a href='#src/story/core.clj/code-anchor-id-:clojure'>code-anchor-id :clojure</a></li><li><a href='#src/story/core.clj/code-anchor-id-:default'>code-anchor-id :default</a></li><li><a href='#src/story/core.clj/code-anchor-id-:javascript'>code-anchor-id :javascript</a></li><li><a href='#src/story/core.clj/code-anchor-id-:vim'>code-anchor-id :vim</a></li><li><a href='#src/story/core.clj/code-anchor-toc'>code-anchor-toc</a></li><li><a href='#src/story/core.clj/comment'>comment</a></li><li><a href='#src/story/core.clj/cond-let'>cond-let</a></li><li><a href='#src/story/core.clj/each'>each</a></li><li><a href='#src/story/core.clj/encode-anchor'>encode-anchor</a></li><li><a href='#src/story/core.clj/end-hidden'>end-hidden</a></li><li><a href='#src/story/core.clj/end-test'>end-test</a></li><li><a href='#src/story/core.clj/gather-lines'>gather-lines</a></li><li><a href='#src/story/core.clj/gather-lines-'>gather-lines-</a></li><li><a href='#src/story/core.clj/heading'>heading</a></li><li><a href='#src/story/core.clj/hidden-comment'>hidden-comment</a></li><li><a href='#src/story/core.clj/html-escape'>html-escape</a></li><li><a href='#src/story/core.clj/html<-'>html&lt;-</a></li><li><a href='#src/story/core.clj/html<--:anchor'>html&lt;- :anchor</a></li><li><a href='#src/story/core.clj/html<--:begin-test'>html&lt;- :begin-test</a></li><li><a href='#src/story/core.clj/html<--:code'>html&lt;- :code</a></li><li><a href='#src/story/core.clj/html<--:comment'>html&lt;- :comment</a></li><li><a href='#src/story/core.clj/html<--:end-test'>html&lt;- :end-test</a></li><li><a href='#src/story/core.clj/html<--:include'>html&lt;- :include</a></li><li><a href='#src/story/core.clj/include'>include</a></li><li><a href='#src/story/core.clj/include-info'>include-info</a></li><li><a href='#src/story/core.clj/inline-brushes'>inline-brushes</a></li><li><a href='#src/story/core.clj/inline-css'>inline-css</a></li><li><a href='#src/story/core.clj/inline-js'>inline-js</a></li><li><a href='#src/story/core.clj/inline-stylesheet'>inline-stylesheet</a></li><li><a href='#src/story/core.clj/inline-theme'>inline-theme</a></li><li><a href='#src/story/core.clj/javascript-setup'>javascript-setup</a></li><li><a href='#src/story/core.clj/lang-brush'>lang-brush</a></li><li><a href='#src/story/core.clj/lang-comment'>lang-comment</a></li><li><a href='#src/story/core.clj/lang-info'>lang-info</a></li><li><a href='#src/story/core.clj/language-aliases'>language-aliases</a></li><li><a href='#src/story/core.clj/languages'>languages</a></li><li><a href='#src/story/core.clj/lazy-each'>lazy-each</a></li><li><a href='#src/story/core.clj/lines-reader'>lines-reader</a></li><li><a href='#src/story/core.clj/link-renderer'>link-renderer</a></li><li><a href='#src/story/core.clj/look-and-feel'>look-and-feel</a></li><li><a href='#src/story/core.clj/map-lines'>map-lines</a></li><li><a href='#src/story/core.clj/markdown'>markdown</a></li><li><a href='#src/story/core.clj/markdown*'>markdown*</a></li><li><a href='#src/story/core.clj/maybe-associate-brush'>maybe-associate-brush</a></li><li><a href='#src/story/core.clj/maybe-code-anchor'>maybe-code-anchor</a></li><li><a href='#src/story/core.clj/message'>message</a></li><li><a href='#src/story/core.clj/normalize-anchor'>normalize-anchor</a></li><li><a href='#src/story/core.clj/process-files'>process-files</a></li><li><a href='#src/story/core.clj/processor'>processor</a></li><li><a href='#src/story/core.clj/read-lines'>read-lines</a></li><li><a href='#src/story/core.clj/render-file'>render-file</a></li><li><a href='#src/story/core.clj/render-files'>render-files</a></li><li><a href='#src/story/core.clj/render-files-'>render-files-</a></li><li><a href='#src/story/core.clj/required'>required</a></li><li><a href='#src/story/core.clj/slurp-file|resource'>slurp-file|resource</a></li><li><a href='#src/story/core.clj/slurp-resource'>slurp-resource</a></li><li><a href='#src/story/core.clj/story'>story</a></li><li><a href='#src/story/core.clj/with-out-stream'>with-out-stream</a></li><li><a href='#src/story/core.clj/wrap-in-tags'>wrap-in-tags</a></li><li><a href='#src/story/core.clj/write-lines'>write-lines</a></li><li><a href='#src/story/core.clj/write-production-file'>write-production-file</a></li><li><a href='#src/story/core.clj/write-production-tree'>write-production-tree</a></li></ul></li><li>src/story/main.clj<br><ul><li><a href='#src/story/main.clj/-main'>-main</a></li><li><a href='#src/story/main.clj/usage'>usage</a></li></ul></li><li>resources/page.js<br><ul><li><a href='#resources/page.js/me_panzoo_story_setup'>me_panzoo_story_setup</a></li></ul></li><li>folding.vim<br><ul><li><a href='#folding.vim/MarkdownLevel'>MarkdownLevel</a></li></ul></li></ul></div><script> ;(function()
{
	// CommonJS
	typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;

	function Brush()
	{
		var keywords =	'break case catch continue ' +
						'default delete do else false  ' +
						'for function if in instanceof ' +
						'new null return super switch ' +
						'this throw true try typeof var while with'
						;

		var r = SyntaxHighlighter.regexLib;
		
		this.regexList = [
			{ regex: r.multiLineDoubleQuotedString,					css: 'string' },			// double quoted strings
			{ regex: r.multiLineSingleQuotedString,					css: 'string' },			// single quoted strings
			{ regex: r.singleLineCComments,							css: 'comments' },			// one line comments
			{ regex: r.multiLineCComments,							css: 'comments' },			// multiline comments
			{ regex: /\s*#.*/gm,									css: 'preprocessor' },		// preprocessor tags like #region and #endregion
			{ regex: new RegExp(this.getKeywords(keywords), 'gm'),	css: 'keyword' }			// keywords
			];
	
		this.forHtmlScript(r.scriptScriptTags);
	};

	Brush.prototype	= new SyntaxHighlighter.Highlighter();
	Brush.aliases	= ['js', 'jscript', 'javascript'];

	SyntaxHighlighter.brushes.JScript = Brush;

	// CommonJS
	typeof(exports) != 'undefined' ? exports.Brush = Brush : null;
})();
 </script>
<script> /**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/wiki/SyntaxHighlighter:Donate
 *
 * @version
 * 2.1.364 (October 15 2009)
 * 
 * @copyright
 * Copyright (C) 2004-2009 Alex Gorbatchev.
 *
 * @license
 * This file is part of SyntaxHighlighter.
 * 
 * SyntaxHighlighter is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SyntaxHighlighter is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SyntaxHighlighter.  If not, see <http://www.gnu.org/copyleft/lesser.html>.
 */
SyntaxHighlighter.brushes.Vimscript = function()
{
	var keywords =	'abc abclear argdo argu argument bel belowright ' +
					'bN bNext breakd breakdel buffer caddb caddbuffer cb cbuffer ' +
					'cex cexpr cg cgetfile checkt checktime cnew cnewer col ' +
					'colder con continue cq cquit delc delcommand diffoff diffu ' +
					'diffupdate dr drop echom echomsg em emenu endt endtry ' +
					'exu exusage fin find foldc foldclose fu function ha ' +
					'hardcopy helpt helptags if is isearch ju jumps kee ' +
					'keepmarks lan language lc lcd lefta leftabove lgetb lgetbuffer ' +
					'lgrepa lgrepadd lla llast lmapc lmapclear lnf lnfile loc ' +
					'lockmarks lpf lpfile ltag mak make menut menutranslate ' +
					'mkvie mkview mzf mzfile next nu number opt options ' +
					'perld perldo pp ppop Print promptr promptrepl ptj ptjump ' +
					'ptp ptprevious pw pwd quit redi redir reg registers ' +
					'rew rewind rubyd rubydo sal sall sba sball sbn ' +
					'sbnext sb sbuffer setf setfiletype sfir sfirst sim simalt ' +
					'sm smap sn snext snor snoremap so source spellr ' +
					'spellrepall spr sprevious star startinsert stopi stopinsert sunmenu tabe ' +
					'tabedit tabm tabmove tabo tabonly ta tag tclf tclfile ' +
					'tj tjump tn tnext tr trewind tu tunmenu undol ' +
					'undolist verb verbose vim vimgrep vmapc vmapclear wh while ' +
					'win winsize wq wv wviminfo xm xmap XMLent xnoremenu ' +
					'abo aboveleft arge argedit as ascii bf bfirst bo ' +
					'botright breakl breaklist buffers cad caddexpr cc cf cfile ' +
					'change cla clast cn cnext colo colorscheme cope copen ' +
					'cr crewind delete diffpatch dig digraphs ds dsearch echon ' +
					'emenu endw endwhile file fini finish folddoc folddoclosed go ' +
					'goto help hid hide ij ijump isp isplit laddb ' +
					'laddbuffer la last lch lchdir lex lexpr lgete lgetexpr ' +
					'lh lhelpgrep lli llist lnew lnewer lNf lNfile lockv ' +
					'lockvar lp lprevious lv lvimgrep ma mark mk mkexrc ' +
					'mkv mkvimrc mz mzscheme Next omapc omapclear pc pclose ' +
					'po pop pre preserve profd profdel ps psearch ptl ' +
					'ptlast ptr ptrewind pyf pyfile quita quitall red redo ' +
					'res resize ri right rubyf rubyfile san sandbox sbf ' +
					'sbfirst sbN sbNext scripte scriptencoding setg setglobal sh shell ' +
					'sla slast smapc smapclear sN sNext snoreme spelld spelldump ' +
					'spellu spellundo sre srewind startr startreplace sts stselect sus ' +
					'suspend tab tabf tabfind tabnew tabp tabprevious tags te ' +
					'tearoff tl tlast tN tNext try una unabbreviate unh ' +
					'unhide ve version vimgrepa vimgrepadd vne vnew winc wincmd ' +
					'wn wnext wqa wqall xmapc xmapclear XMLns xunme al ' +
					'all argg argglobal bad badd bl blast bp bprevious ' +
					'br brewind bun bunload caddf caddfile ccl cclose cfir ' +
					'cfirst changes cl clist cN cNext comc comclear co ' +
					'copy cuna cunabbrev delf delfunction diffpu diffput di display ' +
					'dsp dsplit edit endfo endfor ene enew files fir ' +
					'first foldd folddoopen gr grep helpf helpfind his history ' +
					'il ilist iuna iunabbrev keepalt lad laddexpr later lcl ' +
					'lclose lf lfile lg lgetfile list lmak lmake lne ' +
					'lnext ln lnoremap lol lolder lr lrewind lvimgrepa lvimgrepadd ' +
					'marks mks mksession mod mode nbkey nmapc nmapclear on ' +
					'only ped pedit popu prev previous prof profile pta ' +
					'ptag ptn ptnext pts ptselect py python read redr ' +
					'redraw ret retab rightb rightbelow ru runtime sa sargument ' +
					'sbl sblast sbp sbprevious scrip scriptnames setl setlocal sign ' +
					'sl sleep sme sni sniff snoremenu spe spellgood spellw ' +
					'spellwrong sta stag stj stjump sun sunhide sv sview ' +
					'tabc tabclose tabfir tabfirst tabn tabnext tabr tabrewind tc ' +
					'tcl tf tfirst tm to topleft ts tselect undo ' +
					'unlo unlockvar vert vertical vi visual vs vsplit windo ' +
					'wN wNext write xa xall xme xn xnoremap xunmenu ' +
					'arga argadd argl arglocal ba ball bm bmodified brea ' +
					'break bro browse bw bwipeout cal call cd cgetb ' +
					'cgetbuffer chd chdir clo close cnf cnfile comp compiler ' +
					'cpf cpfile cw cwindow delm delmarks diffsplit dj djump ' +
					'earlier el else endf endfunction ex filetype fix fixdel ' +
					'foldo foldopen grepa grepadd helpg helpgrep iabc iabclear imapc ' +
					'imapclear join keepj keepjumps laddf laddfile lb lbuffer le ' +
					'left lfir lfirst lgr lgrep ll lm lmap lN ' +
					'lNext lo loadview lop lopen ls lw lwindow mat ' +
					'match maca macaction macm macmenu mksp mkspell move new ' +
					'noh nohlsearch open pe perl popu popup print promptf ' +
					'promptfind ptf ptfirst ptN ptNext pu put qa qall ' +
					'rec recover redraws redrawstatus retu return rub ruby rv ' +
					'rviminfo sav saveas sbm sbmodified sbr sbrewind se set ' +
					'sf sfind sil silent sm smagic smenu sno snomagic ' +
					'sor sort spelli spellinfo sp split startg startgreplace st ' +
					'stop sunme syncbind tabd tabdo tabl tablast tabN tabNext ' +
					'tabs tcld tcldo th throw tm tmenu tp tprevious ' +
					'tu undoj undojoin up update vie view viu viusage ' +
					'wa wall winp winpos wp wprevious ws wsverb xit ' +
					'xmenu xnoreme yank argd argdelete ar args bd bdelete ' +
					'bn bnext breaka breakadd bufdo cabc cabclear cat catch ' +
					'ce center cgete cgetexpr che checkpath cmapc cmapclear cNf ' +
					'cNfile conf confirm cp cprevious debugg debuggreedy diffg diffget ' +
					'diffthis dl dlist echoe echoerr elsei elseif en endif ' +
					'exi exit fina finally fo fold for ' +
					'echohl';
					// additional miscelanious keywords, 

	var options = 'acd ambiwidth arabicshape autowriteall backupdir bdlay binary ' +
					'breakat bufhidden cdpath cin cinwords columns completeopt cpo cscopetagorder ' +
					'csverb deco dictionary directory ed encoding errorfile exrc fdls ' +
					'fencs fileformats fmr foldlevel foldtext fsync gfs gtl guioptions ' +
					'hf hk hlsearch imak ims indentexpr is isp keywordprg ' +
					'lazyredraw lispwords ls makeef maxmapdepth mfd mmd modified mousemodel ' +
					'msm numberwidth operatorfunc pastetoggle pexpr pmbfn printexpr pt readonly ' +
					'rightleft rtp sb scroll sect sessionoptions shellpipe shellxquote showbreak ' +
					'shq slm smd spc spf sr sta sts swapfile ' +
					'sxq tabpagemax tags tbis terse thesaurus titleold toolbariconsize tsr ' +
					'ttyfast tx ut verbosefile virtualedit wb wfw wildcharm winaltkeys ' +
					'winminwidth wmnu write ai ambw ari aw backupext beval ' +
					'biosk brk buflisted cedit cindent clipboard com confirm cpoptions ' +
					'cscopeverbose cuc def diff display edcompatible endofline errorformat fcl ' +
					'fdm fex filetype fo foldlevelstart formatexpr ft gfw gtt ' +
					'guipty hh hkmap ic imc imsearch indentkeys isf isprint ' +
					'km lbr list lsp makeprg maxmem mh mmp more ' +
					'mouses mzq nuw opfunc patchexpr pfn popt printfont pumheight ' +
					'redrawtime rightleftcmd ru sbo scrollbind sections sft shellquote shiftround ' +
					'showcmd si sm sn spell spl srr stal su ' +
					'swapsync syn tabstop tagstack tbs textauto tildeop titlestring top ' +
					'ttimeout ttym uc vb vfile visualbell wc wh wildignore ' +
					'window winwidth wmw writeany akm anti arshape awa backupskip ' +
					'bex bioskey browsedir buftype cf cink cmdheight comments consk ' +
					'cpt cspc cul define diffexpr dy ef eol esckeys ' +
					'fcs fdn ff fillchars foldclose foldmarker formatlistpat gcr ghr ' +
					'guicursor guitablabel hi hkmapp icon imcmdline inc indk isfname ' +
					'joinspaces kmp lcs listchars lw mat maxmempattern mis mmt ' +
					'mouse mouseshape mzquantum odev osfiletype patchmode ph preserveindent printheader ' +
					'pvh remap rl ruf sbr scrolljump secure sh shellredir ' +
					'shiftwidth showfulltag sidescroll smartcase so spellcapcheck splitbelow ss startofline ' +
					'sua swb synmaxcol tag tal tenc textmode timeout tl ' +
					'tpm ttimeoutlen ttymouse ul vbs vi vop wcm whichwrap ' +
					'wildmenu winfixheight wiv wop writebackup al antialias autochdir background ' +
					'balloondelay bexpr bk bs casemap cfu cinkeys cmdwinheight commentstring ' +
					'conskey cscopepathcomp csprg cursorcolumn delcombine diffopt ea efm ep ' +
					'et fdc fdo ffs fk foldcolumn foldmethod formatoptions gd ' +
					'go guifont guitabtooltip hid hkp iconstring imd include inex ' +
					'isi js kp linebreak lm lz matchpairs maxmemtot mkspellmem ' +
					'mod mousef mouset nf oft pa path pheader previewheight ' +
					'printmbcharset pvw report rlc ruler sc scrolloff sel shcf ' +
					'shellslash shm showmatch sidescrolloff smartindent softtabstop spellfile splitright ssl ' +
					'statusline suffixes swf syntax tagbsearch tb term textwidth timeoutlen ' +
					'tm tr ttm ttyscroll undolevels vdir viewdir wa wd ' +
					'wi wildmode winfixwidth wiw wrap writedelay aleph ar autoindent ' +
					'backspace ballooneval bg bkc bsdir cb ch cino cmp ' +
					'compatible copyindent cscopeprg csqf cursorline dex digraph ead ei ' +
					'equalalways eventignore fde fdt fileencoding fkmap foldenable foldminlines formatprg ' +
					'gdefault gp guifontset helpfile hidden hl ignorecase imdisable includeexpr ' +
					'inf isident key langmap lines lmap ma matchtime mco ' +
					'ml modeline mousefocus mousetime nrformats ofu para pdev pi ' +
					'previewwindow printmbfont qe restorescreen ro rulerformat scb scrollopt selection ' +
					'shell shelltemp shortmess showmode siso smarttab sol spelllang spr ' +
					'ssop stl suffixesadd switchbuf ta taglength tbi termbidi tf ' +
					'title to ts tty ttytype updatecount ve viewoptions wak ' +
					'weirdinvert wig wildoptions winheight wm wrapmargin ws allowrevins arab ' +
					'autoread backup balloonexpr bh bl bsk ccv charconvert cinoptions ' +
					'cms complete cot cscopequickfix cst cwh dg dip eadirection ' +
					'ek equalprg ex fdi fen fileencodings flp foldexpr foldnestmax ' +
					'fp gfm grepformat guifontwide helpheight highlight hlg im imi ' +
					'incsearch infercase isk keymap langmenu linespace loadplugins macatsui maxcombine ' +
					'mef mls modelines mousehide mp nu omnifunc paragraphs penc ' +
					'pm printdevice printoptions quoteescape revins rs runtimepath scr scs ' +
					'selectmode shellcmdflag shelltype shortname showtabline sj smc sp spellsuggest ' +
					'sps st stmp sw sws tabline tagrelative tbidi termencoding ' +
					'tgst titlelen toolbar tsl ttybuiltin tw updatetime verbose viminfo ' +
					'warn wfh wildchar wim winminheight wmh wrapscan ww altkeymap ' +
					'arabic autowrite backupcopy bdir bin bomb bt cd ci ' +
					'cinw co completefunc cp cscopetag csto debug dict dir ' +
					'eb enc errorbells expandtab noexpandtab fdl fenc fileformat fml foldignore ' +
					'foldopen fs gfn grepprg guiheadroom helplang history hls imactivatekey ' +
					'iminsert inde insertmode iskeyword keymodel laststatus lisp lpl magic ' +
					'maxfuncdepth menuitems mm modifiable mousem mps number opendevice paste ' +
					'pex pmbcs printencoding prompt rdt ri';


	var vimUserAttrbCmplt =	'augroup buffer command dir environment event expression ' +
					'file function help highlight mapping menu option something tag ' +
					'tag_listfiles var';

	var vimLet =	'let unl unlet ';
	
	var vimAutoCmd =	'au autocmd do doautocmd doautoa doautoall';
	
	var vimMap =	'map cm cmap cno cnoremap im imap ino ' +
					'inoremap ln lnoremap nm nmap nn nnoremap no noremap ' +
					'om omap ono onoremap snor snoremap vm vmap vn vnoremap xn xnoremap';
	
	var builtins =	'BufRead ModeMsg None BufAdd BufCreate BufDelete ' +
					'BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew ' +
					'BufNewFile BufRead BufReadCmd BufReadPost BufReadPre ' +
					'BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite ' +
					'BufWriteCmd BufWritePost BufWritePre Cmd-event CmdwinEnter ' +
					'CmdwinLeave ColorScheme CursorHold CursorHoldI CursorMoved ' +
					'CursorMovedI EncodingChanged FileAppendCmd FileAppendPost ' +
					'FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost ' +
					'FileEncoding FileReadCmd FileReadPost FileReadPre FileType ' +
					'FileWriteCmd FileWritePost FileWritePre FilterReadPost ' +
					'FilterReadPre FilterWritePost FilterWritePre FocusGained ' +
					'FocusLost FuncUndefined GUIEnter GUIFailed InsertChange ' +
					'InsertEnter InsertLeave MenuPopup QuickFixCmdPost QuickFixCmdPre ' +
					'RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd ' +
					'SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists ' +
					'Syntax TabEnter TabLeave TermChanged TermResponse User ' +
					'UserGettingBored VimEnter VimLeave VimLeavePre VimResized WinEnter WinLeave ';
	
	
	

	SyntaxHighlighter.regexLib.singleLineVimscriptComments = /^\s*".*$/gm
	SyntaxHighlighter.regexLib.keyMappings = /(\<|&lt;)\w[-\w\[\]]+(\>|&gt;)/ig

	this.regexList = [
		{ regex: SyntaxHighlighter.regexLib.singleLineVimscriptComments,	css: 'comments' },		// one line comments
		{ regex: SyntaxHighlighter.regexLib.keyMappings,	css: 'color3' },		// Vimscript key mappings (e.g. <CR> <C-S-[>)
		{ regex: SyntaxHighlighter.regexLib.doubleQuotedString,		css: 'string' },			// double quoted strings
		{ regex: SyntaxHighlighter.regexLib.singleQuotedString,		css: 'string' },			// single quoted strings
		{ regex: new RegExp(this.getKeywords(options), 'gm'),		css: 'keyword' },			// options
		{ regex: new RegExp(this.getKeywords(vimMap), 'gm'),		css: 'keyword' },			// options
		{ regex: new RegExp(this.getKeywords(vimUserAttrbCmplt), 'gm'),		css: 'keyword' },			// options
		{ regex: new RegExp(this.getKeywords(vimAutoCmd), 'gm'),		css: 'keyword' },			// options
		{ regex: new RegExp(this.getKeywords(keywords), 'gm'),		css: 'keyword' },			// keywords
		{ regex: new RegExp(this.getKeywords(vimLet), 'gm'),		css: 'keyword' },			// keywords
		{ regex: new RegExp(this.getKeywords(builtins), 'gm'),		css: 'color1' }			// keywords
		];
	
	this.forHtmlScript(SyntaxHighlighter.regexLib.scriptScriptTags);
};

SyntaxHighlighter.brushes.Vimscript.prototype	= new SyntaxHighlighter.Highlighter();
SyntaxHighlighter.brushes.Vimscript.aliases	= ['vim', 'vimscript'];
 </script>
<script> // (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
 </script>
<script> // # Javascript setup
//
// This setup code is placed in a function purely to test/show-off story's
// anchor generation.
function me_panzoo_story_setup() {

// SyntaxHighlighter's defaults are not suitable, so they are tweaked.
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.defaults['smart-tabs'] = false;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['unindent'] = false;
  SyntaxHighlighter.defaults['class-name'] = 'code';
  SyntaxHighlighter.all();

// [h50](http://code.google.com/p/h5o/), the HTML5 outliner is used to create
// a table of contents.
  var outline = document.createElement('div');
  outline.setAttribute('id', 'outline');
  outline.innerHTML = HTML5Outline(document.body).asHTML(true);
  var children = outline.firstElementChild.firstElementChild.children;
  outline.removeChild(outline.firstElementChild);
  for (var i = 1; i < children.length; ++i) {
    outline.appendChild(children[i]);
  }
  document.body.appendChild(outline);

  var h1s = document.getElementsByTagName('h1');
  if (h1s.length > 0) document.title = h1s[0].innerText;

// Test code is hidden by default.
  var makeToggle = function(test) {
    var x = document.createElement('div');
    x.setAttribute('class', 'test-toggle');
    x.style.display = 'block';
    x.innerText = '?';
    x.onclick = function() {
      if (test.style.display == 'none') {
        test.style.display = 'block';
      } else {
        test.style.display = 'none';
      }
    };
    return x;
  };
  var tests = document.querySelectorAll('div.test');
  for (var i = 0; i < tests.length; ++i) {
    console.log('test', i, tests[i]);
    var test = tests[i];
    var tog = makeToggle(test);
    test.style.display = 'none';
    test.parentNode.insertBefore(tog, test);
  }

// A master toggle is created if there is more than one test section.
  if (tests.length > 1) {
    var masterTog = document.createElement('div');
    masterTog.setAttribute('id', 'master-toggle');
    masterTog.innerText = '? show all';
    masterTog.onclick = function() {
      var show = masterTog.innerText == '? show all';
      var display = show ? 'block' : 'none';
      masterTog.innerText = show ? '? hide all' : '? show all';
      for (var i = 0; i < tests.length; ++i) {
        tests[i].style.display = display;
      }
    };
    var e = document.querySelector('h1').nextSibling;
    e.parentNode.insertBefore(masterTog, e);
  }
}

me_panzoo_story_setup();
 </script>
